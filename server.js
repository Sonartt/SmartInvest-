require('dotenv').config();
const express = require('express');
const fetch = require('node-fetch');
const bodyParser = require('body-parser');
const cors = require('cors');
const crypto = require('crypto');
const cookieParser = require('cookie-parser');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const storageComplex = require('./storage-complex');
const pochiRoutes = require('./src/routes/pochi-routes');

const app = express();
app.use(cors());
app.use(cookieParser());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use('/api/pochi', pochiRoutes);

const nodeEnv = process.env.NODE_ENV || 'development';
const JWT_SECRET = (() => {
  const secret = process.env.JWT_SECRET;
  const enforceStrict = nodeEnv === 'production' || process.env.ENFORCE_STRICT_JWT === 'true';

  if (enforceStrict) {
    if (!secret) {
      throw new Error('CRITICAL: JWT_SECRET must be set in .env for production');
    }

    if (secret.length < 32 || secret === 'INSECURE-DEV-SECRET-CHANGE-ME') {
      throw new Error('CRITICAL: JWT_SECRET must be at least 32 random characters and not be the default value');
    }

    return secret;
  }

  if (!secret) {
    console.warn('⚠️  JWT_SECRET not set in .env — using insecure fallback (DEV ONLY)');
    return 'INSECURE-DEV-SECRET-CHANGE-ME';
  }

  return secret;
})();
const JWT_EXPIRES = process.env.JWT_EXPIRES || '12h';

const adminLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10,
  keyGenerator: (req) => {
    return req.ip || req.connection?.remoteAddress || 'unknown';
  },
  handler: (_req, res) => {
    return res.status(429).json({ error: 'Too many requests. Please try again later.' });
  },
  standardHeaders: true,
  legacyHeaders: false
});

app.use('/api/admin', adminLimiter);

const userProfiles = new Map();

function sanitizeString(value, maxLength = 200) {
  if (typeof value !== 'string') return '';
  return value.replace(/[<>"'`]/g, '').slice(0, maxLength);
}

function resolveProfileKey(req, body) {
  const payload = verifyTokenFromReq(req);
  if (payload?.email) return payload.email.toLowerCase();
  const email = body?.email || req.query?.email;
  if (typeof email === 'string' && email.includes('@')) return email.toLowerCase();
  return null;
}

// JWT token verification helper
function verifyTokenFromReq(req) {
  const auth = (req.headers.authorization || '').toString();
  let token = null;
  if (auth && auth.startsWith('Bearer ')) token = auth.split(' ')[1];
  if (!token && req.cookies && req.cookies.si_token) token = req.cookies.si_token;
  if (!token) return null;
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (e) {
    return null;
  }
}

// Lightweight health check
app.get('/api/health', (req, res) => {
  return res.json({
    status: 'ok',
    uptime: process.uptime(),
    mpesaEnv: process.env.MPESA_ENV || 'sandbox',
    paypalMode: process.env.PAYPAL_MODE || process.env.PAYPAL_ENV || 'sandbox',
    pochiEnabled: true
  });
});

// Public configuration for frontend contact displays (no secrets)
app.get('/api/public-config', (_req, res) => {
  const supportEmail = process.env.SUPPORT_EMAIL || process.env.NOTIFY_EMAIL || process.env.SMTP_FROM || null;
  const supportPhone = process.env.MPESA_NUMBER || null;
  return res.json({
    supportEmail,
    supportPhone
  });
});

// Admin authentication - requires valid JWT with admin flag OR Basic auth with ADMIN_USER/ADMIN_PASS from .env
function adminAuth(req, res, next) {
  const adminUserEnv = process.env.ADMIN_USER;
  const adminPassEnv = process.env.ADMIN_PASS;
  
  if (!adminUserEnv || !adminPassEnv) {
    return res.status(500).json({ error: 'Admin authentication not configured: set ADMIN_USER and ADMIN_PASS in .env' });
  }
  
  const payload = verifyTokenFromReq(req);
  if (payload && payload.admin) {
    req.user = { email: payload.email, admin: true };
    return next();
  }

  // Fallback: Basic auth if ADMIN_USER configured
  const auth = (req.headers.authorization || '').toString();
  if (auth && auth.startsWith('Basic ')) {
    const creds = Buffer.from(auth.split(' ')[1], 'base64').toString('utf8');
    const [user, pass] = creds.split(':');
    if (user === adminUserEnv && pass === adminPassEnv) {
      req.user = { email: user, admin: true };
      return next();
    }
    res.setHeader('WWW-Authenticate', 'Basic realm="Admin"');
    return res.status(401).end('Unauthorized');
  }

  return res.status(401).json({ error: 'Unauthorized: admin access required' });
}

// Admin: verify access (used by admin dashboard access control script)
app.get('/api/admin/verify-access', adminAuth, (req, res) => {
  return res.json({
    success: true,
    isAdmin: true,
    email: req.user?.email || process.env.ADMIN_USER || null
  });
});

const PORT = process.env.PORT || 3000;

// Helper: get OAuth token for M-Pesa (Daraja)
async function getMpesaAuth() {
  const key = process.env.MPESA_CONSUMER_KEY;
  const secret = process.env.MPESA_CONSUMER_SECRET;
  if (!key || !secret) throw new Error('MPESA keys not configured');
  const basic = Buffer.from(`${key}:${secret}`).toString('base64');
  const url = process.env.MPESA_ENV === 'production'
    ? 'https://api.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials'
    : 'https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials';
  const res = await fetch(url, { headers: { Authorization: `Basic ${basic}` } });
  if (!res.ok) throw new Error('Failed to get M-Pesa token');
  const data = await res.json();
  return data.access_token;
}

// MPESA STK Push (simplified for Daraja sandbox)
app.post('/api/pay/mpesa', async (req, res) => {
  try {
    // Default to 1000 KES if amount not provided
    const { phone, accountReference } = req.body || {};
    const amount = Number(req.body && req.body.amount) || 1000;
    if (!phone) return res.status(400).json({ error: 'phone required' });
    const token = await getMpesaAuth();
    // Prefer explicit MPESA_NUMBER; fall back to older env keys where present
    const shortcode = process.env.MPESA_NUMBER || process.env.MPESA_SHORTCODE || process.env.MPESA_PAYBILL;
    if (!shortcode) throw new Error('MPESA shortcode not configured');
    const passkey = process.env.MPESA_PASSKEY || '';
    const callbackUrl = process.env.MPESA_CALLBACK_URL;
    if (!callbackUrl) throw new Error('MPESA callback URL not configured');

    const endpoint = process.env.MPESA_ENV === 'production'
      ? 'https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest'
      : 'https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest';

    // Build body: if passkey is configured include Timestamp and Password, otherwise omit them
    const body = {
      BusinessShortCode: shortcode,
      TransactionType: 'CustomerPayBillOnline',
      Amount: amount,
      PartyA: phone,
      PartyB: shortcode,
      PhoneNumber: phone,
      CallBackURL: callbackUrl,
      AccountReference: accountReference || process.env.MPESA_ACCOUNT_REF || 'SmartInvest',
      TransactionDesc: 'Payment'
    };
    if (passkey) {
      const timestamp = new Date().toISOString().replace(/[-:TZ.]/g, '').slice(0,14);
      const password = Buffer.from(`${shortcode}${passkey}${timestamp}`).toString('base64');
      body.Password = password;
      body.Timestamp = timestamp;
    } else {
      console.warn('MPESA_PASSKEY not configured — sending STK request without Password/Timestamp (may be rejected by provider)');
    }

    // Log outgoing request (mask sensitive fields)
    logMpesa({ stage: 'request', endpoint, body: maskMpesaBody(body) });

    const mpRes = await fetch(endpoint, {
      method: 'POST',
      headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    // Read raw response for logging and parsing
    const raw = await mpRes.text();
    let parsed = null;
    try { parsed = JSON.parse(raw); } catch (e) { /* not JSON */ }
    logMpesa({ stage: 'response', status: mpRes.status, raw: parsed ? undefined : raw, parsed: parsed || undefined });

    return res.json({ success: true, data: parsed || raw });
  } catch (err) {
    console.error('mpesa error', err.message);
    return res.status(500).json({ error: err.message });
  }
});

// PayPal create order (sandbox by default)
async function getPaypalToken() {
  const id = process.env.PAYPAL_CLIENT_ID;
  const secret = process.env.PAYPAL_CLIENT_SECRET;
  if (!id || !secret) throw new Error('PayPal credentials not set');
  const basic = Buffer.from(`${id}:${secret}`).toString('base64');
  const url = process.env.PAYPAL_ENV === 'production'
    ? 'https://api-m.paypal.com/v1/oauth2/token'
    : 'https://api-m.sandbox.paypal.com/v1/oauth2/token';
  const res = await fetch(url, {
    method: 'POST',
    headers: { Authorization: `Basic ${basic}`, 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'grant_type=client_credentials'
  });
  if (!res.ok) throw new Error('Failed to get PayPal token');
  const d = await res.json();
  return d.access_token;
}

app.post('/api/pay/paypal/create-order', async (req, res) => {
  try {
    const token = await getPaypalToken();
    const url = process.env.PAYPAL_ENV === 'production'
      ? 'https://api-m.paypal.com/v2/checkout/orders'
      : 'https://api-m.sandbox.paypal.com/v2/checkout/orders';
    // Convert 1000 KES to USD (use env EXCHANGE_RATE_KES_USD if provided)
    const rate = Number(process.env.EXCHANGE_RATE_KES_USD) || 0.0065;
    const kesAmount = 1000; // fixed as requested
    const usdAmount = Number((kesAmount * rate).toFixed(2));
    const purchase = {
      intent: 'CAPTURE',
      purchase_units: [ {
        amount: { currency_code: 'USD', value: String(usdAmount) },
        custom_id: req.body.fileId || undefined,
        reference_id: req.body.fileId || undefined
      } ],
      application_context: {
        return_url: process.env.PAYPAL_RETURN_URL || 'https://example.com/paypal/return',
        cancel_url: process.env.PAYPAL_CANCEL_URL || 'https://example.com/paypal/cancel'
      }
    };
    const r = await fetch(url, {
      method: 'POST',
      headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify(purchase)
    });
    const data = await r.json();
    const approve = (data.links||[]).find(l=>l.rel==='approve')?.href;
    return res.json({ success: true, data, approveUrl: approve });
  } catch (err) {
    console.error('paypal error', err.message);
    return res.status(500).json({ error: err.message });
  }
});

// Simple JSON file user store (demo). In production use a real DB.
/* Duplicate USERS_FILE and related requires removed to fix redeclaration error */


// (mailer setup and sendNotificationMail are defined later in the file)

// User cache for improved performance
let userCache = null;
let userCacheTime = 0;

function readUsers() {
  // Use cache if fresh (within TTL)
  const now = Date.now();
  if (userCache && (now - userCacheTime) < USER_CACHE_TTL) {
    // Log cache hit to storage complex
    storageComplex.addCacheEntry('userCache', 'hit', { timestamp: now, cacheAge: now - userCacheTime });
    return userCache;
  }
  
  try {
    const raw = fs.readFileSync(USERS_FILE, 'utf8');
    const users = JSON.parse(raw || '[]');
    // Update cache only after successful read
    userCache = users;
    userCacheTime = now;
    // Log cache miss to storage complex
    storageComplex.addCacheEntry('userCache', 'miss', { timestamp: now, usersCount: users.length });
    return users;
  } catch (e) {
    // Return empty array but don't update cache on error
    storageComplex.addCrashEntry(e, { function: 'readUsers' });
    return [];
  }
}

function writeUsers(users) {
  try {
    fs.writeFileSync(USERS_FILE, JSON.stringify(users, null, 2));
    // Update cache only after successful write
    userCache = users;
    userCacheTime = Date.now();
  } catch (e) {
    // Invalidate cache on write failure to force fresh read
    userCache = null;
    userCacheTime = 0;
    throw e;
  }
}

// Helper: find user by email efficiently
function findUserByEmail(users, email) {
  const emailLower = email.toLowerCase();
  return users.find(u => u.email.toLowerCase() === emailLower);
}

app.post('/api/auth/signup', bodyParser.json(), (req, res) => {
  const { email, password, idNumber, driverLicense, taxNumber } = req.body || {};
  if (!email || !password) return res.status(400).json({ error: 'email and password required' });

  // prevent duplicate
  const users = readUsers();
  if (users.some(u => u.email.toLowerCase() === email.toLowerCase())) {
    return res.status(409).json({ error: 'Email already registered. Please login.' });
  }

  const user = {
    email: email.toLowerCase(),
    passwordHash: bcrypt.hashSync(password, 10),
    createdAt: new Date().toISOString(),
    createdVia: 'signup',
    // registration IDs
    idNumber: idNumber || null,
    driverLicense: driverLicense || null,
    taxNumber: taxNumber || null
  };
  users.push(user);
  writeUsers(users);

  logUserActivity(email, 'signup', req.ip);
  storageComplex.addUserEntry(email, 'signup', { ip: req.ip });

  return res.json({ success: true, message: 'signup successful' });
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body || {};
    if (!email || !password) return res.status(400).json({ error: 'email and password required' });

    const users = readUsers();
    const user = findUserByEmail(users, email);
    if (!user) return res.status(401).json({ error: 'invalid credentials' });

    const ok = bcrypt.compareSync(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: 'invalid credentials' });

    // Determine admin flag: explicit user.admin OR ADMIN_USER env match
    const isAdmin = !!((process.env.ADMIN_USER && String(email).toLowerCase() === String(process.env.ADMIN_USER).toLowerCase()) || user.admin);

    const token = jwt.sign({ email: user.email, admin: !!isAdmin }, JWT_SECRET, { expiresIn: JWT_EXPIRES });

    // Cookie options
    const cookieOptions = {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
      path: '/',
      maxAge: (function() {
        const m = String(JWT_EXPIRES || '12h');
        if (/^\d+$/.test(m)) return Number(m) * 1000;
        const match = m.match(/^(\d+)h$/);
        if (match) return Number(match[1]) * 60 * 60 * 1000;
        return 1000 * 60 * 60 * 12;
      })()
    };
    res.cookie('si_token', token, cookieOptions);

    // Log activity
    logUserActivity(email, 'login', req.ip);
    
    // Log to storage complex
    storageComplex.addUserEntry(email, 'login', { ip: req.ip });
    storageComplex.addLogEntry('info', 'User login', { email });

    return res.json({ 
      success: true, 
      email: user.email, 
      admin: !!isAdmin,
      isPremium: user.isPremium || false,
      premiumExpiresAt: user.premiumExpiresAt || null
    });
  } catch (err) {
    console.error('login error', err && err.message);
    storageComplex.addCrashEntry(err, { endpoint: '/api/auth/login' });
    return res.status(500).json({ error: err && err.message });
  }
});

// 8) Add logout endpoint to clear cookie
app.post('/api/auth/logout', (req, res) => {
  res.clearCookie('si_token', { path: '/' });
  return res.json({ success: true });
});

// GeoIP detection endpoint
app.get('/api/geo', (req, res) => {
  // Try Cloudflare country header first (most reliable when using CF)
  let country = req.headers['cf-ipcountry'];
  
  // Fall back to IP-based detection if no CF header
  if (!country) {
    const ip = req.headers['x-forwarded-for']?.split(',')[0]?.trim() || req.ip || req.connection.remoteAddress;
    // Simple IP range detection for Kenya (simplified - for production use a proper GeoIP database)
    // Kenya IP ranges typically start with specific prefixes, but this is a basic check
    // For localhost/development, default to KE
    if (ip === '::1' || ip === '127.0.0.1' || ip?.startsWith('192.168.') || ip?.startsWith('10.')) {
      country = 'KE'; // Default to Kenya for local development
    } else {
      // For production, you'd use a service like ipapi.co or maxmind
      country = 'OTHER'; // Default to OTHER for unknown IPs
    }
  }
  
  // Normalize to uppercase
  country = String(country).toUpperCase();
  
  // Return KE for Kenya, OTHER for everything else
  const isKenya = country === 'KE' || country === 'KENYA';
  return res.json({ country: isKenya ? 'KE' : 'OTHER' });
});

// 9) Add /api/auth/me to introspect token (header or cookie)
app.get('/api/auth/me', (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) return res.status(401).json({ error: 'invalid or missing token' });
  return res.json({ success: true, email: payload.email, admin: !!payload.admin });
});

// PayPal create order (sandbox by default)
async function getPaypalToken() {
  const id = process.env.PAYPAL_CLIENT_ID;
  const secret = process.env.PAYPAL_CLIENT_SECRET;
  if (!id || !secret) throw new Error('PayPal credentials not set');
  const basic = Buffer.from(`${id}:${secret}`).toString('base64');
  const url = process.env.PAYPAL_ENV === 'production'
    ? 'https://api-m.paypal.com/v1/oauth2/token'
    : 'https://api-m.sandbox.paypal.com/v1/oauth2/token';
  const res = await fetch(url, {
    method: 'POST',
    headers: { Authorization: `Basic ${basic}`, 'Content-Type': 'application/x-www-form-urlencoded' },
    body: 'grant_type=client_credentials'
  });
  if (!res.ok) throw new Error('Failed to get PayPal token');
  const d = await res.json();
  return d.access_token;
}

app.post('/api/pay/paypal/create-order', async (req, res) => {
  try {
    const token = await getPaypalToken();
    const url = process.env.PAYPAL_ENV === 'production'
      ? 'https://api-m.paypal.com/v2/checkout/orders'
      : 'https://api-m.sandbox.paypal.com/v2/checkout/orders';
    // Convert 1000 KES to USD (use env EXCHANGE_RATE_KES_USD if provided)
    const rate = Number(process.env.EXCHANGE_RATE_KES_USD) || 0.0065;
    const kesAmount = 1000; // fixed as requested
    const usdAmount = Number((kesAmount * rate).toFixed(2));
    const purchase = {
      intent: 'CAPTURE',
      purchase_units: [ {
        amount: { currency_code: 'USD', value: String(usdAmount) },
        custom_id: req.body.fileId || undefined,
        reference_id: req.body.fileId || undefined
      } ],
      application_context: {
        return_url: process.env.PAYPAL_RETURN_URL || 'https://example.com/paypal/return',
        cancel_url: process.env.PAYPAL_CANCEL_URL || 'https://example.com/paypal/cancel'
      }
    };
    const r = await fetch(url, {
      method: 'POST',
      headers: { Authorization: `Bearer ${token}`, 'Content-Type': 'application/json' },
      body: JSON.stringify(purchase)
    });
    const data = await r.json();
    const approve = (data.links||[]).find(l=>l.rel==='approve')?.href;
    return res.json({ success: true, data, approveUrl: approve });
  } catch (err) {
    console.error('paypal error', err.message);
    return res.status(500).json({ error: err.message });
  }
});

// Simple JSON file user store (demo). In production use a real DB.
const USERS_FILE = './data/users.json';
const fs = require('fs');
const path = require('path');
const bcrypt = require('bcryptjs');
const nodemailer = require('nodemailer');
const multer = require('multer');
const { v4: uuidv4 } = require('uuid');

// Logging helpers for MPESA debug (enabled when MPESA_DEBUG=true)
const LOG_DIR = path.join(__dirname, 'logs');
if (!fs.existsSync(LOG_DIR)) try { fs.mkdirSync(LOG_DIR, { recursive: true }); } catch (e) { /* ignore */ }
const MPESA_LOG = path.join(LOG_DIR, 'mpesa.log');
function maskMpesaBody(b) {
  try {
    const copy = Object.assign({}, b);
    if (copy && copy.Password) copy.Password = '[REDACTED]';
    return copy;
  } catch (e) { return b; }
}
function logMpesa(entry) {
  if (String(process.env.MPESA_DEBUG).toLowerCase() !== 'true') return;
  try {
    const out = { ts: new Date().toISOString(), ...entry };
    fs.appendFileSync(MPESA_LOG, JSON.stringify(out) + '\n');
  } catch (e) { console.error('mpesa log write error', e && e.message); }
}

// Setup mail transporter if SMTP config provided
let mailer = null;
if (process.env.SMTP_HOST) {
  mailer = nodemailer.createTransport({
    host: process.env.SMTP_HOST,
    port: Number(process.env.SMTP_PORT) || 587,
    secure: process.env.SMTP_SECURE === 'true',
    auth: process.env.SMTP_USER ? { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS } : undefined
  });
}

async function sendNotificationMail(opts={}){
  if (!mailer) return;
  const to = opts.to || process.env.NOTIFY_EMAIL;
  if (!to) return;
  try {
    const info = await mailer.sendMail({
      from: process.env.SMTP_FROM || process.env.NOTIFY_EMAIL,
      to,
      subject: opts.subject || 'SmartInvest Notification',
      text: opts.text || '',
      html: opts.html
    });
    // If using Ethereal, log preview URL
    try {
      const preview = nodemailer.getTestMessageUrl(info);
      if (preview) console.log('Ethereal preview URL:', preview);
    } catch (e) {
      // ignore
    }
    return info;
  } catch (e) {
    console.error('mail error', e.message);
  }
}

// If mailer isn't configured via SMTP and we're not in production, create an Ethereal test account
(async function initEthereal(){
  if (mailer) return; // already configured via SMTP
  if (process.env.NODE_ENV === 'production') return;
  try {
    const testAccount = await nodemailer.createTestAccount();
    mailer = nodemailer.createTransport({
      host: testAccount.smtp.host,
      port: testAccount.smtp.port,
      secure: testAccount.smtp.secure,
      auth: { user: testAccount.user, pass: testAccount.pass }
    });
    console.log('Ethereal test account created for outgoing email:');
    console.log('  user:', testAccount.user);
    console.log('  pass:', testAccount.pass);
    console.log('Use the preview URLs logged when messages are sent to view emails.');
  } catch (e) {
    console.error('Failed to create Ethereal account:', e.message);
  }
})();

// User cache for improved performance
// let userCache = null;
// let userCacheTime = 0;
const USER_CACHE_TTL = 5000; // 5 seconds cache

function readUsers() {
  // Use cache if fresh (within TTL)
  const now = Date.now();
  if (userCache && (now - userCacheTime) < USER_CACHE_TTL) {
    // Log cache hit to storage complex
    storageComplex.addCacheEntry('userCache', 'hit', { timestamp: now, cacheAge: now - userCacheTime });
    return userCache;
  }
  
  try {
    const raw = fs.readFileSync(USERS_FILE, 'utf8');
    const users = JSON.parse(raw || '[]');
    // Update cache only after successful read
    userCache = users;
    userCacheTime = now;
    // Log cache miss to storage complex
    storageComplex.addCacheEntry('userCache', 'miss', { timestamp: now, usersCount: users.length });
    return users;
  } catch (e) {
    // Return empty array but don't update cache on error
    storageComplex.addCrashEntry(e, { function: 'readUsers' });
    return [];
  }
}

function writeUsers(users) {
  try {
    fs.writeFileSync(USERS_FILE, JSON.stringify(users, null, 2));
    // Update cache only after successful write
    userCache = users;
    userCacheTime = Date.now();
  } catch (e) {
    // Invalidate cache on write failure to force fresh read
    userCache = null;
    userCacheTime = 0;
    throw e;
  }
}

// Helper: find user by email efficiently
function findUserByEmail(users, email) {
  const emailLower = email.toLowerCase();
  return users.find(u => u.email.toLowerCase() === emailLower);
}

// Password reset request
app.post('/api/auth/reset-password-request', async (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ error: 'email required' });
    
    const users = readUsers();
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user) {
      // Don't reveal if email exists
      return res.json({ success: true, message: 'If account exists, reset email sent' });
    }
    
    // Generate reset token
    const token = crypto.randomBytes(32).toString('hex');
    user.resetToken = token;
    user.resetTokenExpiry = Date.now() + 3600000; // 1 hour
    writeUsers(users);
    
    // Send reset email with activity logs
    sendPasswordResetEmail(email, token);
    logUserActivity(email, 'password_reset_requested', req.ip);
    
    return res.json({ success: true, message: 'If account exists, reset email sent' });
  } catch (err) {
    console.error('reset password request error', err.message);
    return res.status(500).json({ error: err.message });
  }
});

// Password reset confirm
app.post('/api/auth/reset-password-confirm', async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    if (!token || !newPassword) return res.status(400).json({ error: 'token and newPassword required' });
    
    const users = readUsers();
    const user = users.find(u => u.resetToken === token && u.resetTokenExpiry > Date.now());
    if (!user) return res.status(400).json({ error: 'Invalid or expired reset token' });
    
    // Update password
    user.passwordHash = bcrypt.hashSync(newPassword, 10);
    delete user.resetToken;
    delete user.resetTokenExpiry;
    writeUsers(users);
    
    logUserActivity(user.email, 'password_reset_completed', req.ip);
    sendNotificationMail({ to: user.email, subject: 'Password Changed', text: 'Your SmartInvest password was successfully changed.' });
    
    return res.json({ success: true, message: 'Password reset successful' });
  } catch (err) {
    console.error('reset password confirm error', err.message);
    return res.status(500).json({ error: err.message });
  }
});

// Webhook endpoints to receive provider callbacks (simple logging + ack)
app.post('/api/pay/mpesa/callback', (req, res) => {
  try {
    const payload = req.body;
    // If a callback secret is configured, require HMAC-SHA256 signature in header `x-mpesa-signature`
    const secret = process.env.MPESA_CALLBACK_SECRET;
    if (secret) {
      const sigHeader = (req.headers['x-mpesa-signature'] || req.headers['x-signature'] || '').toString();
      const computed = crypto.createHmac('sha256', secret).update(JSON.stringify(req.body)).digest('hex');
      if (!sigHeader || sigHeader !== computed) {
        console.warn('mpesa callback signature mismatch');
        return res.status(401).json({ error: 'invalid signature' });
      }
    }
    const tx = { provider: 'mpesa', timestamp: new Date().toISOString(), payload };
    const file = './transactions.json';
    const arr = require('fs').existsSync(file) ? JSON.parse(require('fs').readFileSync(file)) : [];
    arr.push(tx);
    require('fs').writeFileSync(file, JSON.stringify(arr, null, 2));
    // Strict mapping: only use AccountReference value to map to a file id (exact match)
    try {
      const body = payload.Body || payload.body || payload;
      const stk = (body && (body.stkCallback || body.STKCallback)) || body;
      const items = (stk && stk.CallbackMetadata && stk.CallbackMetadata.Item) || (body && body.CallbackMetadata && body.CallbackMetadata.Item) || [];
      const accItem = Array.isArray(items) ? items.find(i => (String(i.Name||i.name||'')).toLowerCase() === 'accountreference' || (String(i.Name||i.name||'')).toLowerCase() === 'account') : null;
      const acctVal = accItem && accItem.Value ? String(accItem.Value).trim() : null;
      const resultCode = stk && stk.ResultCode !== undefined ? stk.ResultCode : null;
      
      // Find phone number efficiently with single pass
      let phone = null;
      if (Array.isArray(items)) {
        for (const item of items) {
          const name = item.Name || item.name || '';
          if (name === 'PhoneNumber' || name === 'phone') {
            phone = item;
            break;
          }
        }
      }
      
      // Auto-grant premium on successful payment
      if (resultCode === 0) {
        if (phone && phone.Value) {
          const phoneNum = String(phone.Value);
          const email = phoneNum + '@mpesa.local';
          // Ensure user exists
          const users = readUsers();
          let user = users.find(u => u.email === email);
          if (!user) {
            user = {
              email,
              passwordHash: bcrypt.hashSync(crypto.randomBytes(16).toString('hex'), 10),
              createdAt: new Date().toISOString(),
              createdVia: 'mpesa_payment',
              phone: phoneNum
            };
            users.push(user);
            writeUsers(users);
          }
          grantPremium(email, 30, 'mpesa_payment', 'system');
        }
      }
      
      if (acctVal) {
        const files = readFilesMeta();
        const match = files.find(f => f.id === acctVal);
        if (match) {
          const emailLike = phone && phone.Value ? String(phone.Value)+'@mpesa.local' : '';
          grantPurchase(match.id, emailLike, 'mpesa', { raw: payload });
        }
      }
    } catch (e) { console.error('mpesa grant detection error', e.message); }
    return res.status(200).json({ received: true });
  } catch (err) {
    console.error('mpesa callback error', err.message);
    return res.status(500).end();
  }
});

app.post('/api/pay/paypal/webhook', (req, res) => {
  try {
    const payload = req.body;
    const tx = { provider: 'paypal', timestamp: new Date().toISOString(), payload };
    const file = './transactions.json';
    const arr = require('fs').existsSync(file) ? JSON.parse(require('fs').readFileSync(file)) : [];
    arr.push(tx);
    require('fs').writeFileSync(file, JSON.stringify(arr, null, 2));
    // Strict mapping: only honor explicit PayPal fields `custom_id`, `reference_id` or `invoice_id` matching a file id
    try {
      const resource = payload.resource || payload.body || payload;
      const eventType = payload.event_type || '';
      const payerEmail = resource?.payer?.email_address || resource?.payer?.email || payload?.payer_email || '';
      
      // Auto-grant premium on successful payment
      if ((eventType === 'PAYMENT.CAPTURE.COMPLETED' || eventType === 'CHECKOUT.ORDER.APPROVED') && payerEmail) {
        const users = readUsers();
        let user = users.find(u => u.email.toLowerCase() === payerEmail.toLowerCase());
        if (!user) {
          user = {
            email: payerEmail.toLowerCase(),
            passwordHash: bcrypt.hashSync(crypto.randomBytes(16).toString('hex'), 10),
            createdAt: new Date().toISOString(),
            createdVia: 'paypal_payment'
          };
          users.push(user);
          writeUsers(users);
        }
        grantPremium(payerEmail, 30, 'paypal_payment', 'system');
      }
      
      const files = readFilesMeta();
      let fileId = null;
      const pus = (resource.purchase_units || resource.purchaseUnits || []);
      for (const pu of pus) {
        const candidates = [pu.custom_id, pu.reference_id, pu.invoice_id].filter(Boolean).map(String);
        for (const c of candidates) {
          const match = files.find(f => f.id === c);
          if (match) { fileId = match.id; break; }
        }
        if (fileId) break;
      }
      if (fileId) grantPurchase(fileId, payerEmail, 'paypal', { raw: payload });
    } catch (e) { console.error('paypal grant detection error', e.message); }
    return res.status(200).json({ received: true });
  } catch (err) {
    console.error('paypal webhook error', err.message);
    return res.status(500).end();
  }
});

// Manual KCB Bank Transfer (simple flow)
app.post('/api/pay/kcb/manual', (req, res) => {
  try {
    const { name, email, amount, reference } = req.body;
    if (!name || !email || !amount) return res.status(400).json({ error: 'name, email and amount required' });

    const bankName = process.env.KCB_BANK_NAME;
    const accountName = process.env.KCB_ACCOUNT_NAME;
    const accountNumber = process.env.KCB_ACCOUNT_NUMBER;
    if (!bankName || !accountName || !accountNumber) {
      return res.status(500).json({ error: 'KCB bank details not configured' });
    }

    const tx = {
      provider: 'kcb_manual',
      timestamp: new Date().toISOString(),
      name,
      email,
      amount,
      reference: reference || '',
      status: 'pending',
      account: {
        bank: bankName,
        accountName,
        accountNumber
      }
    };

    const file = './transactions.json';
    const arr = fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : [];
    arr.push(tx);
    fs.writeFileSync(file, JSON.stringify(arr, null, 2));

    // send notification to admin (if configured)
    sendNotificationMail({
      subject: `New KCB manual transfer recorded — ${tx.amount} KES`,
      text: `A new manual bank transfer was recorded:\n\nName: ${tx.name}\nEmail: ${tx.email}\nAmount: ${tx.amount}\nReference: ${tx.reference || tx.timestamp}\n\nAccount: ${tx.account.bank} ${tx.account.accountName} ${tx.account.accountNumber}`,
      html: `<p>A new manual bank transfer was recorded:</p><ul><li>Name: ${tx.name}</li><li>Email: ${tx.email}</li><li>Amount: ${tx.amount}</li><li>Reference: ${tx.reference || tx.timestamp}</li></ul><p>Account: <strong>${tx.account.bank} — ${tx.account.accountName} — ${tx.account.accountNumber}</strong></p>`
    });

    // send confirmation to user
    sendNotificationMail({ to: tx.email, subject: 'SmartInvest — Bank transfer recorded', text: `Thank you. Please pay KES ${tx.amount} to ${tx.account.accountNumber} (Ref: ${tx.reference || tx.timestamp}).` });

    return res.json({ success: true, message: 'manual bank transfer recorded', transaction: tx });
  } catch (err) {
    console.error('kcb manual error', err.message);
    return res.status(500).json({ error: err.message });
  }
});

// Admin endpoints
app.get('/api/admin/kcb-transfers', adminAuth, (req, res) => {
  try {
    const file = './transactions.json';
    const arr = fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : [];
    const only = arr.filter(t => t.provider === 'kcb_manual');
    
    // Add pagination
    const page = Math.max(1, Number(req.query.page) || 1);
    const limit = Math.min(100, Math.max(1, Number(req.query.limit) || 50));
    const start = (page - 1) * limit;
    const end = start + limit;
    const paginated = only.slice(start, end);
    
    return res.json({ 
      success: true, 
      transfers: paginated,
      pagination: {
        page,
        limit,
        total: only.length,
        hasMore: end < only.length
      }
    });
  } catch (e) {
    console.error('admin list error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Consolidated payments ledger for admins
app.get('/api/admin/payments', adminAuth, (req, res) => {
  const files = readFilesMeta();
  const allPayments = readTransactions().map(tx => summarizeTransaction(tx, files));
  const purchases = readPurchases();
  
  // Add pagination
  const page = Math.max(1, Number(req.query.page) || 1);
  const limit = Math.min(100, Math.max(1, Number(req.query.limit) || 50));
  const start = (page - 1) * limit;
  const end = start + limit;
  const payments = allPayments.slice(start, end);
  
  return res.json({ 
    success: true, 
    payments,
    purchases,
    pagination: {
      page,
      limit,
      total: allPayments.length,
      hasMore: end < allPayments.length
    }
  });
});

app.post('/api/admin/kcb/mark-paid', adminAuth, (req, res) => {
  try {
    const { timestamp, note } = req.body;
    if (!timestamp) return res.status(400).json({ error: 'timestamp required' });
    const file = './transactions.json';
    const arr = fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : [];
    const idx = arr.findIndex(t => t.provider === 'kcb_manual' && t.timestamp === timestamp);
    if (idx === -1) return res.status(404).json({ error: 'transfer not found' });
    arr[idx].status = 'paid';
    arr[idx].paidAt = new Date().toISOString();
    if (note) arr[idx].note = note;
    fs.writeFileSync(file, JSON.stringify(arr, null, 2));

    // Auto-grant premium to user
    const email = arr[idx].email;
    if (email) {
      const users = readUsers();
      let user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
      if (!user) {
        user = {
          email: email.toLowerCase(),
          passwordHash: bcrypt.hashSync(crypto.randomBytes(16).toString('hex'), 10),
          createdAt: new Date().toISOString(),
          createdVia: 'kcb_payment'
        };
        users.push(user);
        writeUsers(users);
      }
      grantPremium(email, 30, 'kcb_manual_payment', process.env.ADMIN_USER || 'admin');
    }

    // notify user
    sendNotificationMail({ to: arr[idx].email, subject: 'SmartInvest — Transfer marked paid', text: `Your bank transfer of KES ${arr[idx].amount} has been marked as received. Thank you.` });

    // Strict mapping: only auto-grant when bank `reference` exactly equals a file id
    try {
      const ref = String(arr[idx].reference || '').trim();
      if (ref) {
        const files = readFilesMeta();
        const match = files.find(f => f.id === ref);
        if (match) grantPurchase(match.id, arr[idx].email, 'kcb_manual', { transactionTimestamp: arr[idx].timestamp });
      }
    } catch (e) { console.error('auto-grant on mark-paid error', e.message); }

    return res.json({ success: true, transfer: arr[idx] });
  } catch (e) {
    console.error('mark paid error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Admin: list all users with full details including premium status
app.get('/api/admin/users', adminAuth, (req, res) => {
  try {
    const users = readUsers();
    const sanitized = users.map(u => ({
      email: u.email,
      createdAt: u.createdAt,
      createdVia: u.createdVia,
      isPremium: u.isPremium || false,
      premiumExpiresAt: u.premiumExpiresAt,
      premiumGrantedAt: u.premiumGrantedAt,
      premiumReason: u.premiumReason,
      premiumGrantedBy: u.premiumGrantedBy,
      phone: u.phone,
      activityLogs: (u.activityLogs || []).slice(-10)
    }));
    return res.json({ success: true, users: sanitized });
  } catch (e) {
    console.error('admin users list error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Admin: manually grant premium to a user
app.post('/api/admin/grant-premium', adminAuth, (req, res) => {
  try {
    const { email, days, reason } = req.body;
    if (!email) return res.status(400).json({ error: 'email required' });
    const daysNum = Number(days) || 30;
    const grantedBy = process.env.ADMIN_USER || 'admin';
    const user = grantPremium(email, daysNum, reason || 'manual_admin_grant', grantedBy);
    if (!user) return res.status(404).json({ error: 'User not found' });
    return res.json({ success: true, user: { email: user.email, isPremium: user.isPremium, premiumExpiresAt: user.premiumExpiresAt } });
  } catch (e) {
    console.error('grant premium error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Admin: revoke premium from a user
app.post('/api/admin/revoke-premium', adminAuth, (req, res) => {
  try {
    const { email } = req.body;
    if (!email) return res.status(400).json({ error: 'email required' });
    const users = readUsers();
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user) return res.status(404).json({ error: 'User not found' });
    user.isPremium = false;
    user.premiumRevokedAt = new Date().toISOString();
    delete user.premiumExpiresAt;
    writeUsers(users);
    sendNotificationMail({ to: email, subject: 'Premium Access Revoked', text: 'Your premium access has been revoked by an administrator.' });
    return res.json({ success: true });
  } catch (e) {
    console.error('revoke premium error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Admin: dashboard stats
app.get('/api/admin/dashboard-stats', adminAuth, (req, res) => {
  try {
    const users = readUsers();
    const files = readFilesMeta();
    const messages = readMessages();
    const purchases = readPurchases();
    const premiumUsers = users.filter(u => u.isPremium && (!u.premiumExpiresAt || new Date(u.premiumExpiresAt) > new Date()));
    return res.json({
      success: true,
      totalUsers: users.length,
      premiumUsers: premiumUsers.length,
      filesCount: files.length,
      pendingMessages: messages.filter(m => !m.replies || m.replies.length === 0).length,
      totalPurchases: purchases.length
    });
  } catch (e) {
    console.error('dashboard stats error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Serve admin.html protected by basic auth (if configured)
app.get('/admin.html', adminAuth, (req, res) => {
  const adminFile = path.join(__dirname, 'admin.html');
  if (fs.existsSync(adminFile)) return res.sendFile(adminFile);
  return res.status(404).send('admin.html not found');
});

// --- File marketplace: uploads, metadata, purchases, downloads ---
const UPLOADS_DIR = path.join(__dirname, 'uploads');
const FILES_JSON = path.join(__dirname, 'data', 'files.json');
const SCENARIOS_FILE = path.join(__dirname, 'data', 'scenarios.json');
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR, { recursive: true });
if (!fs.existsSync(path.join(__dirname, 'data'))) fs.mkdirSync(path.join(__dirname, 'data'), { recursive: true });
if (!fs.existsSync(FILES_JSON)) fs.writeFileSync(FILES_JSON, JSON.stringify([], null, 2));
if (!fs.existsSync(SCENARIOS_FILE)) fs.writeFileSync(SCENARIOS_FILE, JSON.stringify([], null, 2));

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, UPLOADS_DIR),
  filename: (req, file, cb) => {
    const id = crypto.randomUUID();
    const safe = file.originalname.replace(/[^a-zA-Z0-9.\-_]/g, '_');
    cb(null, `${id}-${safe}`);
  }
});
const upload = multer({ storage });

function readFilesMeta(){
  try { return JSON.parse(fs.readFileSync(FILES_JSON, 'utf8') || '[]'); } catch(e){ return []; }
}
function writeFilesMeta(arr){ fs.writeFileSync(FILES_JSON, JSON.stringify(arr, null, 2)); }

// Download tokens and purchases file handling
const TOKENS_FILE = path.join(__dirname, 'data', 'tokens.json');
const PURCHASES_FILE = path.join(__dirname, 'data', 'purchases.json');
if (!fs.existsSync(TOKENS_FILE)) fs.writeFileSync(TOKENS_FILE, JSON.stringify({}, null, 2));
if (!fs.existsSync(PURCHASES_FILE)) fs.writeFileSync(PURCHASES_FILE, JSON.stringify([], null, 2));

function readTokens() {
  try { return JSON.parse(fs.readFileSync(TOKENS_FILE, 'utf8') || '{}'); } 
  catch(e) { return {}; }
}
function writeTokens(data) { 
  fs.writeFileSync(TOKENS_FILE, JSON.stringify(data, null, 2)); 
}
function readPurchases() {
  try { return JSON.parse(fs.readFileSync(PURCHASES_FILE, 'utf8') || '[]'); } 
  catch(e) { return []; }
}
function writePurchases(data) { 
  fs.writeFileSync(PURCHASES_FILE, JSON.stringify(data, null, 2)); 
}

// Public: list files available for purchasers (legacy behavior)
app.get('/api/files', requirePaidUser, (req, res) => {
  try {
    const files = readFilesMeta();
    const purchases = readPurchases().filter(p => p.email && String(p.email).toLowerCase() === req.purchaserEmail);
    const ownedIds = purchases.map(p => p.fileId);
    const owned = files.filter(f => ownedIds.includes(f.id));
    return res.json({ success: true, files: owned });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

// Premium: list all published files (no per-file purchase required)
app.get('/api/premium/files', requirePremium, (req, res) => {
  try {
    const files = readFilesMeta().filter(f => f.published);
    return res.json({ success: true, files });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

// Admin: upload a file with metadata (title, price, description)
app.post('/api/admin/upload', adminAuth, upload.single('file'), (req, res) => {
  try {
    const { title, price, description } = req.body;
    if (!req.file) return res.status(400).json({ error: 'file is required (multipart form-data field name: file)' });
    const meta = readFilesMeta();
    const id = crypto.randomUUID();
    const item = {
      id,
      title: title || req.file.originalname,
      description: description || '',
      price: Number(price || 0),
      filename: req.file.filename,
      originalName: req.file.originalname,
      size: req.file.size,
      uploadedAt: new Date().toISOString()
    };
    meta.push(item);
    writeFilesMeta(meta);
    return res.json({ success: true, file: item });
  } catch (e) { console.error('upload error', e.message); return res.status(500).json({ error: e.message }); }
});

// Admin: delete file metadata and file
app.delete('/api/admin/files/:id', adminAuth, (req, res) => {
  try {
    const id = req.params.id;
    const meta = readFilesMeta();
    const idx = meta.findIndex(f=>f.id===id);
    if (idx === -1) return res.status(404).json({ error: 'file not found' });
    const removed = meta.splice(idx,1)[0];
    writeFilesMeta(meta);
    const p = path.join(UPLOADS_DIR, removed.filename);
    if (fs.existsSync(p)) fs.unlinkSync(p);
    return res.json({ success: true });
  } catch (e) { console.error('delete file error', e.message); return res.status(500).json({ error: e.message }); }
});

// NOTE: The demo `/api/purchase` endpoint was removed. Integrate real payment providers and
// grant purchases via provider webhooks or admin grants. This improves security by avoiding
// client-side simulated purchases.

// Download a file if a valid token exists for that file
app.get('/download/:id', (req, res) => {
  try {
    const id = req.params.id;
    const token = req.query.token || req.headers['x-download-token'];
    if (!token) return res.status(401).send('Missing token');
    const txFile = './transactions.json';
    const arr = fs.existsSync(txFile) ? JSON.parse(fs.readFileSync(txFile)) : [];
    const ok = arr.find(t=>t.provider==='file_purchase' && t.fileId===id && t.token===token && t.paidAt);
    if (!ok) return res.status(403).send('Invalid or expired token');
    const files = readFilesMeta();
    const file = files.find(f=>f.id===id);
    if (!file) return res.status(404).send('File not found');
    const p = path.join(UPLOADS_DIR, file.filename);
    if (!fs.existsSync(p)) return res.status(404).send('File missing on server');
    return res.download(p, file.originalName);
  } catch (e) { console.error('download error', e.message); return res.status(500).send('download failed'); }
});

// (uploads/data initialization handled earlier in file)

// Read saved transactions from disk (mpesa, paypal, kcb_manual, etc.)
function readTransactions() {
  try {
    const file = './transactions.json';
    if (!fs.existsSync(file)) return [];
    const raw = fs.readFileSync(file, 'utf8') || '[]';
    return JSON.parse(raw);
  } catch (e) {
    console.error('readTransactions error', e.message);
    return [];
  }
}

// Summarize a raw transaction into a compact, admin-friendly shape
function summarizeTransaction(tx, files = []) {
  const base = {
    provider: tx.provider || 'unknown',
    createdAt: tx.timestamp || tx.time || new Date().toISOString(),
    status: tx.status || 'pending',
    amount: tx.amount || null,
    currency: tx.currency || null,
    email: tx.email || null,
    phone: tx.phone || null,
    reference: tx.reference || null,
    receipt: tx.receipt || null,
    note: tx.note || null
  };

  const cleanLower = (s) => (s ? String(s).toLowerCase() : '');

  // Provider-specific enrichment
  if ((tx.provider || '').toLowerCase() === 'mpesa') {
    const payload = tx.payload || {};
    const body = payload.Body || payload.body || payload;
    const stk = (body && (body.stkCallback || body.STKCallback)) || body || {};
    const items = (stk.CallbackMetadata && stk.CallbackMetadata.Item) || [];
    const findItem = (name) => items.find(i => cleanLower(i.Name) === name || cleanLower(i.name) === name);
    const amount = findItem('amount')?.Value || null;
    const phone = findItem('phonenumber')?.Value || findItem('msisdn')?.Value || null;
    const receipt = findItem('mpesareceiptnumber')?.Value || null;
    const account = findItem('accountreference')?.Value || findItem('account')?.Value || null;
    const resultCode = stk.ResultCode;
    const status = resultCode === 0 ? 'success' : (resultCode === 1032 ? 'timeout' : 'failed');

    base.amount = amount || base.amount;
    base.currency = 'KES';
    base.phone = phone || base.phone;
    base.email = base.email || (phone ? `${phone}@mpesa.local` : null);
    base.reference = account || base.reference;
    base.receipt = receipt || base.receipt;
    base.status = status || base.status;
    base.description = stk.ResultDesc || base.description;
  }

  if ((tx.provider || '').toLowerCase() === 'paypal') {
    const payload = tx.payload || {};
    const resource = payload.resource || payload.body || payload;
    const pu = (resource.purchase_units || resource.purchaseUnits || [])[0] || {};
    const amountObj = pu.amount || {};
    const amount = Number(amountObj.value || base.amount) || null;
    const currency = amountObj.currency_code || base.currency || 'USD';
    const reference = pu.custom_id || pu.reference_id || pu.invoice_id || base.reference;
    const email = resource?.payer?.email_address || base.email;
    const status = resource?.status || payload?.event_type || base.status;

    base.amount = amount;
    base.currency = currency;
    base.reference = reference;
    base.email = email;
    base.status = status;
  }

  if ((tx.provider || '').toLowerCase() === 'kcb_manual') {
    base.status = tx.status || base.status;
    base.amount = tx.amount || base.amount;
    base.currency = base.currency || 'KES';
    base.email = tx.email || base.email;
    base.reference = tx.reference || base.reference;
    base.account = tx.account || null;
  }

  // Map reference to a file name if possible
  if (base.reference) {
    const match = files.find(f => f.id === base.reference);
    if (match) base.fileTitle = match.title;
  }

  return base;
}

// Middleware: require that the requester is a purchaser. Checks for purchaser email
// in header `x-user-email`, query `email` or request body `email`. Returns 402
// if no purchase found for that email. This enforces that file listings are
// accessible only to paying users.
function requirePaidUser(req, res, next) {
  try {
    let email = (req.headers['x-user-email'] || req.query.email || (req.body && req.body.email));
    if (!email) {
      const payload = verifyTokenFromReq(req);
      if (payload && payload.email) email = payload.email;
    }
    if (!email) return res.status(402).json({ error: 'Payment required: include purchaser email in x-user-email header or ?email= or sign in' });
    const e = String(email).toLowerCase();
    const purchases = readPurchases();
    const ok = Array.isArray(purchases) && purchases.find(p => p.email && String(p.email).toLowerCase() === e);
    if (!ok) return res.status(402).json({ error: 'No purchases found for this email' });
    req.purchaserEmail = e;
    return next();
  } catch (e) {
    console.error('requirePaidUser error', e && e.message);
    return res.status(500).json({ error: 'server error' });
  }
}

// Middleware: require premium access (admin bypass allowed)
function requirePremium(req, res, next) {
  try {
    // Admin bypass: check for admin auth
    const auth = req.headers.authorization;
    if (auth && auth.startsWith('Basic ')) {
      const creds = Buffer.from(auth.split(' ')[1], 'base64').toString('utf8');
      const [user, pass] = creds.split(':');
      if (user === process.env.ADMIN_USER && pass === process.env.ADMIN_PASS) {
        req.isAdmin = true;
        return next();
      }
    }
    
    // Check for user email and premium status
    const email = (req.headers['x-user-email'] || req.query.email || (req.body && req.body.email));
    if (!email) return res.status(402).json({ error: 'Premium access required: please sign in', premiumRequired: true });
    
    const e = String(email).toLowerCase();
    if (!hasPremium(e)) {
      return res.status(402).json({ 
        error: 'Premium subscription required', 
        premiumRequired: true,
        upgradeUrl: `${process.env.BASE_URL || ''}/premium`
      });
    }
    
    req.userEmail = e;
    return next();
  } catch (e) {
    console.error('requirePremium error', e && e.message);
    return res.status(500).json({ error: 'server error' });
  }
}

function readScenarios(){ try { return JSON.parse(fs.readFileSync(SCENARIOS_FILE, 'utf8')||'[]'); } catch(e){ return []; } }
function writeScenarios(d){ fs.writeFileSync(SCENARIOS_FILE, JSON.stringify(d, null, 2)); }

// Grant premium access to a user (by email) for specified days
function grantPremium(email, days = 30, reason = 'payment', grantedBy = 'system') {
  try {
    if (!email) return null;
    const users = readUsers();
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user) return null;
    const expiresAt = new Date(Date.now() + days * 24 * 60 * 60 * 1000).toISOString();
    user.isPremium = true;
    user.premiumExpiresAt = expiresAt;
    user.premiumGrantedAt = new Date().toISOString();
    user.premiumReason = reason;
    user.premiumGrantedBy = grantedBy;
    writeUsers(users);
    // Send premium welcome email with terms and content details
    sendPremiumWelcomeEmail(email);
    return user;
  } catch (e) {
    console.error('grantPremium error', e.message);
    return null;
  }
}

// Check if user has active premium
function hasPremium(email) {
  try {
    const users = readUsers();
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user || !user.isPremium) return false;
    if (user.premiumExpiresAt && new Date(user.premiumExpiresAt) < new Date()) {
      user.isPremium = false;
      writeUsers(users);
      return false;
    }
    return true;
  } catch (e) {
    return false;
  }
}

// Send welcome email with terms, laws, conditions, and premium content description
function sendPremiumWelcomeEmail(email) {
  const subject = 'Welcome to SmartInvest Premium — Terms & Content Access';
  const html = `
    <h2>Welcome to SmartInvest Premium!</h2>
    <p>Thank you for joining SmartInvest Africa Premium. Your account now has full access to exclusive content.</p>
    
    <h3>Premium Content Includes:</h3>
    <ul>
      <li><strong>Investment Academy:</strong> 50+ video lessons covering Investing 101, Trading Essentials, SME Funding, and Digital Assets</li>
      <li><strong>Advanced Tools:</strong> Portfolio tracker, risk profiler, AI-powered recommendations</li>
      <li><strong>VIP Community:</strong> Exclusive forum, weekly webinars, and direct mentor access</li>
      <li><strong>Premium Files:</strong> Downloadable resources, templates, and guides</li>
    </ul>

    <h3>Terms and Conditions:</h3>
    <p>By using SmartInvest Premium, you agree to:</p>
    <ul>
      <li>Use content for personal educational purposes only</li>
      <li>Not share, redistribute, or resell any premium content</li>
      <li>Respect intellectual property rights of all materials</li>
      <li>Comply with all applicable laws and regulations in your jurisdiction</li>
    </ul>

    <h3>Legal Framework:</h3>
    <p>SmartInvest Africa operates under:</p>
    <ul>
      <li>Data Protection: GDPR and local data protection laws</li>
      <li>Financial Services: Licensed under applicable African financial regulations</li>
      <li>Consumer Protection: Full compliance with consumer rights legislation</li>
      <li>Anti-Money Laundering (AML): KYC procedures as required by law</li>
    </ul>

    <h3>Disclaimer:</h3>
    <p>Investment education and tools are provided for informational purposes. SmartInvest Africa does not provide financial advice. 
    All investment decisions are your responsibility. Past performance does not guarantee future results.</p>

    <p>For full terms: <a href="${process.env.BASE_URL || 'https://smartinvest.africa'}/terms.html">View Terms & Conditions</a></p>
    
    <p>Questions? Contact us at ${process.env.SUPPORT_EMAIL || process.env.NOTIFY_EMAIL || process.env.SMTP_FROM || ''}</p>
  `;
  const text = `Welcome to SmartInvest Premium! You now have access to: Investment Academy (50+ lessons), Advanced Tools, VIP Community, and Premium Files. By using our service you agree to our Terms & Conditions and applicable laws. Full terms at ${process.env.BASE_URL || 'https://smartinvest.africa'}/terms.html`;
  sendNotificationMail({ to: email, subject, html, text });
}

// Send password reset email with user activity logs
function sendPasswordResetEmail(email, resetToken) {
  try {
    const users = readUsers();
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user) return;
    
    const logs = user.activityLogs || [];
    const recentLogs = logs.slice(-10).reverse();
    const logHtml = recentLogs.map(l => `<li>${l.timestamp}: ${l.action} ${l.ip ? '(IP: ' + l.ip + ')' : ''}</li>`).join('');
    
    const subject = 'Password Reset Request — SmartInvest';
    const resetUrl = `${process.env.BASE_URL || 'https://smartinvest.africa'}/reset-password?token=${resetToken}`;
    const html = `
      <h2>Password Reset Request</h2>
      <p>We received a request to reset your password for ${email}.</p>
      <p><a href="${resetUrl}" style="background: #7C3AED; color: white; padding: 12px 24px; text-decoration: none; border-radius: 8px; display: inline-block;">Reset Password</a></p>
      <p>This link expires in 1 hour.</p>
      
      <h3>Recent Account Activity:</h3>
      <ul>${logHtml || '<li>No recent activity</li>'}</ul>
      
      <p><small>If you didn't request this reset, please ignore this email and contact support immediately.</small></p>
    `;
    const text = `Password reset requested for ${email}. Reset link: ${resetUrl} (expires in 1 hour). Recent activity: ${recentLogs.map(l => l.timestamp + ': ' + l.action).join('; ')}`;
    sendNotificationMail({ to: email, subject, html, text });
  } catch (e) {
    console.error('sendPasswordResetEmail error', e.message);
  }
}

// Log user activity
function logUserActivity(email, action, ip = null) {
  try {
    const users = readUsers();
    const user = users.find(u => u.email.toLowerCase() === email.toLowerCase());
    if (!user) return;
    user.activityLogs = user.activityLogs || [];
    user.activityLogs.push({ timestamp: new Date().toISOString(), action, ip });
    // Keep only last 100 logs - use splice for efficiency when removing multiple items
    if (user.activityLogs.length > 100) {
      user.activityLogs.splice(0, user.activityLogs.length - 100);
    }
    writeUsers(users);
  } catch (e) {
    console.error('logUserActivity error', e.message);
  }
}

// Grant a purchase for a fileId and email (idempotent)
function grantPurchase(fileId, email, provider='manual', meta={}){
  try {
    if (!fileId) return null;
    const files = readFilesMeta(); if (!files.find(f=>f.id===fileId)) return null;
    if (!email) email = (meta.email || '').toLowerCase();
    const purchases = readPurchases();
    const exists = purchases.find(p => 
      p.fileId === fileId && 
      email && 
      p.email && 
      p.email.toLowerCase() === email.toLowerCase()
    );
    if (exists) return exists;
    const entry = { id: uuidv4(), fileId, email: email? email.toLowerCase() : '', provider, at: new Date().toISOString(), meta };
    purchases.push(entry);
    writePurchases(purchases);
    // notify user if we have an email
    if (email) {
      const file = files.find(f=>f.id===fileId);
      sendNotificationMail({ to: email, subject: `Purchase confirmed — ${file?.title||'File'}`, text: `You now have access to download ${file?.title||fileId}.` });
    }
    return entry;
  } catch (e) { console.error('grantPurchase error', e.message); return null; }
}

// Multer setup (already defined earlier)

// Scenarios endpoints: store/load/delete simple calculator scenarios (premium required)
app.get('/api/scenarios', requirePremium, (req, res) => {
  try {
    const list = readScenarios();
    return res.json({ success: true, scenarios: list });
  } catch (e) { console.error('scenarios list error', e.message); return res.status(500).json({ error: e.message }); }
});

app.get('/api/scenarios/:id', requirePremium, (req, res) => {
  try {
    const id = req.params.id;
    const list = readScenarios();
    const s = list.find(x=>x.id===id);
    if (!s) return res.status(404).json({ error: 'not found' });
    return res.json({ success: true, scenario: s });
  } catch (e) { console.error('get scenario error', e.message); return res.status(500).json({ error: e.message }); }
});

app.post('/api/scenarios', requirePremium, express.json(), (req, res) => {
  try {
    const body = req.body || {};
    const name = body.name || ('scenario-' + Date.now());
    const id = uuidv4();
    const entry = { id, name, type: body.type || 'investment', settings: body.settings || {}, result: body.result || null, createdAt: new Date().toISOString() };
    const list = readScenarios();
    list.push(entry);
    writeScenarios(list);
    return res.json({ success: true, scenario: entry });
  } catch (e) { console.error('save scenario error', e.message); return res.status(500).json({ error: e.message }); }
});

// Deleting scenarios is admin-only to avoid accidental removals
app.delete('/api/scenarios/:id', adminAuth, (req, res) => {
  try {
    const id = req.params.id;
    const list = readScenarios();
    const idx = list.findIndex(x=>x.id===id);
    if (idx === -1) return res.status(404).json({ error: 'not found' });
    list.splice(idx,1);
    writeScenarios(list);
    return res.json({ success: true });
  } catch (e) { console.error('delete scenario error', e.message); return res.status(500).json({ error: e.message }); }
});

// Admin: upload file (pdfs, docs, images)
app.post('/api/admin/files/upload', adminAuth, upload.single('file'), (req, res) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'file required' });
    const { title, description, price, published } = req.body;
    const files = readFilesMeta();
    const id = uuidv4();
    const entry = {
      id,
      title: title || req.file.originalname,
      description: description || '',
      filename: req.file.filename,
      originalName: req.file.originalname,
      size: req.file.size,
      mime: req.file.mimetype,
      price: Number(price) || 0,
      published: published === 'true' || false,
      createdAt: new Date().toISOString()
    };
    files.push(entry);
    writeFilesMeta(files);
    return res.json({ success: true, file: entry });
  } catch (e) { console.error('upload error', e.message); return res.status(500).json({ error: e.message }); }
});

// Admin: list files
app.get('/api/admin/files', adminAuth, (req, res) => {
  try { const files = readFilesMeta(); return res.json({ success: true, files }); } catch(e){ return res.status(500).json({ error: e.message }); }
});

// Route '/api/files' is defined earlier for legacy purchaser listing.
// Prefer '/api/premium/files' for premium-wide listing.

// Public catalog: list published files (title, price, id) for browsing before purchase
app.get('/api/catalog', (req, res) => {
  try {
    const files = readFilesMeta()
      .filter(f => f.published)
      .map(f => ({ id: f.id, title: f.title, price: f.price, description: f.description }));
    return res.json({ success: true, files });
  } catch (e) {
    return res.status(500).json({ error: e.message });
  }
});

// Public catalog: single item details by id (published only)
app.get('/api/catalog/:id', (req, res) => {
  try {
    const { id } = req.params;
    const file = readFilesMeta().find(f => f.id === id && f.published);
    if (!file) return res.status(404).json({ error: 'not found' });
    const out = {
      id: file.id,
      title: file.title,
      description: file.description,
      price: file.price,
      createdAt: file.createdAt || file.uploadedAt,
      size: file.size,
      mime: file.mime || null
    };
    return res.json({ success: true, file: out });
  } catch (e) { return res.status(500).json({ error: e.message }); }
});

// Admin: update file metadata
app.post('/api/admin/files/:id', adminAuth, (req, res) => {
  try {
    const id = req.params.id;
    const files = readFilesMeta();
    const idx = files.findIndex(f=>f.id===id);
    if (idx===-1) return res.status(404).json({ error: 'file not found' });
    const allowed = ['title','description','price','published'];
    allowed.forEach(k=>{ if (k in req.body) files[idx][k] = (k==='price'? Number(req.body[k]) : (k==='published'? (req.body[k]===true || req.body[k]==='true') : req.body[k])); });
    writeFilesMeta(files);
    return res.json({ success: true, file: files[idx] });
  } catch(e){ console.error(e); return res.status(500).json({ error: e.message }); }
});

// Messages: public messaging where visitors can post and admin can reply
const MESSAGES_FILE = path.join(__dirname, 'data', 'messages.json');
if (!fs.existsSync(MESSAGES_FILE)) fs.writeFileSync(MESSAGES_FILE, JSON.stringify([], null, 2));

function readMessages(){ try { return JSON.parse(fs.readFileSync(MESSAGES_FILE, 'utf8')||'[]'); } catch(e){ return []; } }
function writeMessages(d){ fs.writeFileSync(MESSAGES_FILE, JSON.stringify(d, null, 2)); }

// Public: post a message (name optional, email optional)
app.post('/api/messages', express.json(), (req, res) => {
  try {
    const { name, email, message } = req.body || {};
    if (!message || !String(message).trim()) return res.status(400).json({ error: 'message required' });
    const msgs = readMessages();
    const id = uuidv4();
    const entry = { id, name: name || 'Visitor', email: email || '', message: String(message).trim(), replies: [], createdAt: new Date().toISOString() };
    msgs.push(entry);
    writeMessages(msgs);
    // notify admin of new message
    sendNotificationMail({ subject: 'New site message', text: `${entry.name} wrote: ${entry.message}`, html: `<p><strong>${entry.name}</strong>: ${entry.message}</p>` });
    return res.json({ success: true, message: entry });
  } catch (e) { console.error('post message error', e.message); return res.status(500).json({ error: e.message }); }
});

// Public: list messages (visible to everyone)
app.get('/api/messages', (req, res) => {
  try {
    const msgs = readMessages();
    return res.json({ success: true, messages: msgs });
  } catch (e) { console.error('list messages error', e.message); return res.status(500).json({ error: e.message }); }
});

// Admin: list messages (full view)
app.get('/api/admin/messages', adminAuth, (req, res) => {
  try {
    const msgs = readMessages();
    return res.json({ success: true, messages: msgs });
  } catch (e) { console.error('admin list messages error', e.message); return res.status(500).json({ error: e.message }); }
});

// Admin: reply to a message (only admin can reply)
app.post('/api/admin/messages/:id/reply', adminAuth, express.json(), (req, res) => {
  try {
    const id = req.params.id;
    const { reply } = req.body || {};
    if (!reply || !String(reply).trim()) return res.status(400).json({ error: 'reply text required' });
    const msgs = readMessages();
    const idx = msgs.findIndex(m => m.id === id);
    if (idx === -1) return res.status(404).json({ error: 'message not found' });
    const r = { id: uuidv4(), by: process.env.ADMIN_USER || 'admin', message: String(reply).trim(), at: new Date().toISOString() };
    msgs[idx].replies = msgs[idx].replies || [];
    msgs[idx].replies.push(r);
    writeMessages(msgs);
    // notify original sender if email provided
    if (msgs[idx].email) {
      sendNotificationMail({ to: msgs[idx].email, subject: 'Reply to your message on SmartInvest', text: r.message, html: `<p>${r.message}</p>` });
    }
    return res.json({ success: true, reply: r });
  } catch (e) { console.error('reply message error', e.message); return res.status(500).json({ error: e.message }); }
});

// Storage Complex Endpoints - Admin Only
// Get all storage complex data
app.get('/api/admin/storage-complex', adminAuth, (req, res) => {
  try {
    const data = storageComplex.getAllStorageData();
    const adminEmail = (req.user && req.user.email) || ADMIN_EMAIL;
    storageComplex.addAdminEntry(adminEmail, 'view_storage_complex', { ip: req.ip });
    return res.json({ success: true, data });
  } catch (e) { 
    console.error('storage complex error', e.message); 
    storageComplex.addCrashEntry(e, { endpoint: '/api/admin/storage-complex' });
    return res.status(500).json({ error: e.message }); 
  }
});

// Get storage complex by type
app.get('/api/admin/storage-complex/:type', adminAuth, (req, res) => {
  try {
    const type = req.params.type;
    const validTypes = ['cache', 'crashes', 'users', 'admin', 'logs'];
    if (!validTypes.includes(type)) {
      return res.status(400).json({ error: 'Invalid type. Must be one of: cache, crashes, users, admin, logs' });
    }
    const data = storageComplex.getStorageByType(type);
    const adminEmail = (req.user && req.user.email) || ADMIN_EMAIL;
    storageComplex.addAdminEntry(adminEmail, 'view_storage_type', { type, ip: req.ip });
    return res.json({ success: true, type, data });
  } catch (e) { 
    console.error('storage complex type error', e.message); 
    storageComplex.addCrashEntry(e, { endpoint: '/api/admin/storage-complex/:type' });
    return res.status(500).json({ error: e.message }); 
  }
});

// Get storage complex statistics
app.get('/api/admin/storage-stats', adminAuth, (req, res) => {
  try {
    const stats = storageComplex.getStorageStats();
    return res.json({ success: true, stats });
  } catch (e) { 
    console.error('storage stats error', e.message); 
    return res.status(500).json({ error: e.message }); 
  }
});

// Clear storage by type (admin only)
app.post('/api/admin/storage-complex/:type/clear', adminAuth, (req, res) => {
  try {
    const type = req.params.type;
    const validTypes = ['cache', 'crashes', 'users', 'admin', 'logs'];
    if (!validTypes.includes(type)) {
      return res.status(400).json({ error: 'Invalid type. Must be one of: cache, crashes, users, admin, logs' });
    }
    const success = storageComplex.clearStorageByType(type);
    const adminEmail = (req.user && req.user.email) || ADMIN_EMAIL;
    storageComplex.addAdminEntry(adminEmail, 'clear_storage_type', { type, ip: req.ip });
    return res.json({ success, message: `${type} storage cleared` });
  } catch (e) { 
    console.error('clear storage error', e.message); 
    storageComplex.addCrashEntry(e, { endpoint: '/api/admin/storage-complex/:type/clear' });
    return res.status(500).json({ error: e.message }); 
  }
});

// Admin: grant purchase to an email for a file (manual grant)
app.post('/api/admin/files/:id/grant', adminAuth, (req, res) => {
  try {
    const id = req.params.id; const { email } = req.body;
    if (!email) return res.status(400).json({ error: 'email required' });
    const files = readFilesMeta(); const file = files.find(f=>f.id===id);
    if (!file) return res.status(404).json({ error: 'file not found' });
    const purchases = readPurchases();
    purchases.push({ id: uuidv4(), fileId: id, email: email.toLowerCase(), grantedBy: req.headers['x-admin']||'admin', at: new Date().toISOString() });
    writePurchases(purchases);
    sendNotificationMail({ to: email, subject: `Access granted to ${file.title}`, text: `You have been granted access to download ${file.title}.` });
    return res.json({ success: true });
  } catch(e){ console.error(e); return res.status(500).json({ error: e.message }); }
});

// Public: request download token
// - Allows if the email owns a purchase for the file, OR the email has active premium
app.post('/api/download/request', express.json(), (req, res) => {
  try {
    const { fileId, email } = req.body;
    if (!fileId || !email) return res.status(400).json({ error: 'fileId and email required' });
    const e = email.toLowerCase();
    const purchases = readPurchases();
    const owns = purchases.find(p => p.fileId === fileId && p.email === e);
    const premiumOk = hasPremium(e);
    if (!owns && !premiumOk) return res.status(402).json({ error: 'Access denied: premium or purchase required' });
    const tokens = readTokens();
    const token = uuidv4();
    const expireAt = Date.now() + (60*60*1000); // 1 hour
    tokens[token] = { fileId, email: e, expireAt };
    writeTokens(tokens);
    const url = `${req.protocol}://${req.get('host')}/download/${token}`;
    return res.json({ success: true, url, expiresAt: new Date(expireAt).toISOString() });
  } catch(e){ console.error(e); return res.status(500).json({ error: e.message }); }
});

// Premium: get full metadata for a file by id (for premium users)
app.get('/api/files/:id', requirePremium, (req, res) => {
  try {
    const { id } = req.params;
    const file = readFilesMeta().find(f => f.id === id && f.published);
    if (!file) return res.status(404).json({ error: 'not found' });
    return res.json({ success: true, file });
  } catch (e) { return res.status(500).json({ error: e.message }); }
});

// Serve download by token
app.get('/download/:token', (req, res) => {
  try {
    const token = req.params.token;
    const tokens = readTokens();
    const entry = tokens[token];
    if (!entry) return res.status(404).send('Invalid or expired token');
    if (Date.now() > entry.expireAt) { delete tokens[token]; writeTokens(tokens); return res.status(410).send('Token expired'); }
    const files = readFilesMeta(); const file = files.find(f=>f.id===entry.fileId);
    if (!file) return res.status(404).send('File not found');
    const filePath = path.join(UPLOADS_DIR, file.filename);
    if (!fs.existsSync(filePath)) return res.status(404).send('File missing');
    res.setHeader('Content-Disposition', `attachment; filename="${file.originalName.replace(/\"/g,'') }"`);
    return res.sendFile(filePath);
  } catch(e){ console.error('download error', e.message); return res.status(500).send('Server error'); }
});

// CSV export of KCB manual transfers
app.get('/api/admin/kcb-export', adminAuth, (req, res) => {
  try {
    const file = './transactions.json';
    const arr = fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : [];
    const rows = arr.filter(t => t.provider === 'kcb_manual');
    const header = ['timestamp','name','email','amount','reference','status','paidAt','note'];
    // Optimize: single-pass CSV generation instead of nested maps
    const csvRows = rows.map(r => {
      const values = [r.timestamp, r.name, r.email, r.amount, (r.reference||''), (r.status||''), (r.paidAt||''), (r.note||'')];
      return values.map(v => `"${String(v).replace(/"/g,'""')}"`).join(',');
    });
    const csv = [header.join(','), ...csvRows].join('\n');
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="kcb-transfers.csv"');
    res.send(csv);
  } catch (e) {
    console.error('export error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Reconcile bank entries: accepts JSON { entries: [...] }
app.post('/api/admin/kcb/reconcile', adminAuth, (req, res) => {
  try {
    const incoming = Array.isArray(req.body) ? req.body : (req.body.entries || []);
    if (!incoming || !incoming.length) return res.status(400).json({ error: 'no entries provided' });
    const file = './transactions.json';
    const arr = fs.existsSync(file) ? JSON.parse(fs.readFileSync(file)) : [];
    const pending = arr.filter(t => t.provider === 'kcb_manual' && t.status === 'pending');
    const results = { matched: [], unmatched: [] };
    
    // Build lookup maps for O(1) matching instead of O(n²) nested loops
    const pendingByRefAmount = new Map();
    const pendingByAmount = new Map();
    
    pending.forEach(p => {
      const ref = (p.reference || '').toString().trim();
      const amt = Number(p.amount);
      if (ref) {
        const key = `${ref}:${amt}`;
        pendingByRefAmount.set(key, p);
      }
      // For amount-only matching, store array of candidates with same amount
      if (!pendingByAmount.has(amt)) {
        pendingByAmount.set(amt, []);
      }
      pendingByAmount.get(amt).push(p);
    });
    
    incoming.forEach(entry => {
      const ref = (entry.reference || entry.ref || '').toString().trim();
      const amt = Number(entry.amount || entry.value || 0);
      let found = null;
      
      // Try exact match by reference + amount first (O(1) lookup)
      if (ref) {
        const key = `${ref}:${amt}`;
        found = pendingByRefAmount.get(key);
      }
      
      // Fall back to amount-only match - find first unmatched candidate
      if (!found) {
        const candidates = pendingByAmount.get(amt) || [];
        found = candidates.find(c => 
          !c._matched && 
          (!entry.email || c.email === entry.email)
        );
      }
      
      if (found) {
        const idx = arr.findIndex(x=>x.timestamp===found.timestamp && x.provider==='kcb_manual');
        arr[idx].status = 'paid';
        arr[idx].paidAt = new Date().toISOString();
        arr[idx].reconciledWith = entry;
        results.matched.push({ transaction: arr[idx], entry });
        // notify user
        sendNotificationMail({ to: arr[idx].email, subject: 'SmartInvest — Transfer reconciled', text: `Your bank transfer of KES ${arr[idx].amount} was matched and marked as received.` });
        
        // Mark as matched to prevent double-matching
        found._matched = true;
        if (ref) pendingByRefAmount.delete(`${ref}:${amt}`);
        // Don't delete the entire amount mapping - just mark this candidate as matched
      } else {
        results.unmatched.push(entry);
      }
    });
    fs.writeFileSync(file, JSON.stringify(arr, null, 2));
    return res.json({ success: true, summary: { matched: results.matched.length, unmatched: results.unmatched.length }, results });
  } catch (e) {
    console.error('reconcile error', e.message);
    return res.status(500).json({ error: e.message });
  }
});

// Note: debug endpoints like `/api/pay/mpesa/token` removed to avoid exposing sensitive tokens.

// Serve tools folder (static files like the investment calculator)
app.use('/tools', express.static(path.join(__dirname, 'tools')));

// Serve public and wwwroot folders for CSS, JS, and other assets
app.use('/public', express.static(path.join(__dirname, 'public')));
app.use('/wwwroot', express.static(path.join(__dirname, 'wwwroot')));

// Serve root HTML files - must be AFTER API routes so /api routes take precedence
// This enables access to all dashboards like /dashboard.html, /marketplace.html, /index.html, etc.
app.use(express.static(path.join(__dirname), {
  setHeaders: (res, path) => {
    // Set cache headers for HTML files (short cache)
    if (path.endsWith('.html')) {
      res.set('Cache-Control', 'public, max-age=3600');
    }
    // Set cache headers for static assets (long cache)
    if (path.match(/\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|ttf|eot)$/)) {
      res.set('Cache-Control', 'public, max-age=86400');
    }
  }
}));

// Catch-all: serve index.html for SPA routing (optional - uncomment if needed)
// app.get('*', (req, res) => {
//   res.sendFile(path.join(__dirname, 'index.html'));
// });

// Premium Academy Content API (requires premium subscription)
app.get('/api/academy/courses', requirePremium, (req, res) => {
  const courses = [
    { id: 'investing-101', title: 'Investing 101', level: 'Beginner', lessons: 15, duration: '3 hours' },
    { id: 'trading-essentials', title: 'Trading Essentials', level: 'Intermediate', lessons: 20, duration: '5 hours' },
    { id: 'sme-funding', title: 'SME Funding Readiness', level: 'SME', lessons: 12, duration: '4 hours' },
    { id: 'digital-assets', title: 'Digital Assets & Crypto', level: 'Advanced', lessons: 18, duration: '6 hours' }
  ];
  return res.json({ success: true, courses });
});

app.get('/api/academy/courses/:id', requirePremium, (req, res) => {
  const courseContent = {
    'investing-101': { title: 'Investing 101', modules: ['Basics', 'Risk Management', 'Diversification'] },
    'trading-essentials': { title: 'Trading Essentials', modules: ['Market Analysis', 'Trading Psychology', 'Risk Control'] },
    'sme-funding': { title: 'SME Funding Readiness', modules: ['Pitching', 'Valuation', 'Investor Relations'] },
    'digital-assets': { title: 'Digital Assets & Crypto', modules: ['Custody', 'Security', 'Strategy'] }
  };
  const course = courseContent[req.params.id];
  if (!course) return res.status(404).json({ error: 'Course not found' });
  return res.json({ success: true, course });
});

// Premium Tools API
app.get('/api/tools/portfolio', requirePremium, (req, res) => {
  return res.json({ success: true, message: 'Portfolio tracker data', isPremium: true });
});

app.get('/api/tools/risk-profiler', requirePremium, (req, res) => {
  return res.json({ success: true, message: 'Risk profiler data', isPremium: true });
});

app.get('/api/tools/recommendations', requirePremium, (req, res) => {
  return res.json({ success: true, message: 'AI recommendations', isPremium: true });
});

// ============================================================================
// MODERN PAYMENT SYSTEM API ENDPOINTS
// ============================================================================

// Helper: require user authentication (lighter than requirePremium)
function requireAuth(req, res, next) {
  const payload = verifyTokenFromReq(req);
  if (!payload || !payload.email) {
    return res.status(401).json({ error: 'Authentication required' });
  }
  req.user = { email: payload.email, admin: payload.admin || false };
  return next();
}

// Helper: write transactions to file
function writeTransactions(transactions) {
  try {
    const file = './transactions.json';
    fs.writeFileSync(file, JSON.stringify(transactions, null, 2));
  } catch (e) {
    console.error('writeTransactions error', e.message);
  }
}

// 1. Process Payment (POST /api/payments/process)
app.post('/api/payments/process', requireAuth, async (req, res) => {
  try {
    const { amount, currency, method, phone, email, description, reference } = req.body;
    
    // Validation
    if (!amount || !currency || !method) {
      return res.status(400).json({ 
        success: false, 
        error: 'Missing required fields: amount, currency, method' 
      });
    }
    
    // Generate transaction ID
    const transactionId = `txn_${Date.now()}_${crypto.randomBytes(4).toString('hex')}`;
    
    // Create transaction record
    const transaction = {
      id: transactionId,
      userId: req.user.email,
      amount: parseFloat(amount),
      currency,
      method,
      status: 'processing',
      description: description || '',
      email: email || req.user.email,
      phone: phone || '',
      reference: reference || `SMI-${Date.now()}-${crypto.randomBytes(3).toString('hex')}`,
      timestamp: new Date().toISOString(),
      provider: method,
      createdAt: new Date().toISOString()
    };
    
    // Read existing transactions
    const transactions = readTransactions();
    transactions.push(transaction);
    writeTransactions(transactions);
    
    // Simulate payment processing based on method
    // In production, integrate with actual payment gateways
    let processingMessage = '';
    switch (method) {
      case 'mpesa':
        processingMessage = 'M-Pesa STK push initiated. Check your phone.';
        // In production: call actual M-Pesa API
        break;
      case 'paystack':
        processingMessage = 'Redirecting to Paystack payment page...';
        // In production: create Paystack transaction
        break;
      case 'stripe':
        processingMessage = 'Stripe payment session created.';
        // In production: create Stripe payment intent
        break;
      case 'paypal':
        processingMessage = 'Redirecting to PayPal...';
        // In production: create PayPal order
        break;
      case 'flutterwave':
        processingMessage = 'Flutterwave payment initiated.';
        // In production: create Flutterwave transaction
        break;
      default:
        processingMessage = 'Payment processing...';
    }
    
    return res.json({
      success: true,
      transactionId,
      reference: transaction.reference,
      amount: transaction.amount,
      currency: transaction.currency,
      status: 'processing',
      message: processingMessage
    });
    
  } catch (err) {
    console.error('Payment processing error:', err.message);
    return res.status(500).json({ 
      success: false, 
      error: 'Payment processing failed', 
      message: err.message 
    });
  }
});

// 2. Record Transaction (POST /api/payments/record)
app.post('/api/payments/record', requireAuth, (req, res) => {
  try {
    const { transactionId, amount, currency, method, status, email, phone, reference, description } = req.body;
    
    if (!transactionId) {
      return res.status(400).json({ 
        success: false, 
        error: 'transactionId is required' 
      });
    }
    
    const transactions = readTransactions();
    const existingTx = transactions.find(tx => tx.id === transactionId || tx.reference === reference);
    
    if (existingTx) {
      // Update existing transaction
      existingTx.status = status || existingTx.status;
      existingTx.email = email || existingTx.email;
      existingTx.phone = phone || existingTx.phone;
      existingTx.updatedAt = new Date().toISOString();
      if (description) existingTx.description = description;
    } else {
      // Create new record
      transactions.push({
        id: transactionId,
        userId: req.user.email,
        amount: parseFloat(amount) || 0,
        currency: currency || 'USD',
        method: method || 'unknown',
        status: status || 'pending',
        description: description || '',
        email: email || req.user.email,
        phone: phone || '',
        reference: reference || transactionId,
        timestamp: new Date().toISOString(),
        provider: method || 'unknown',
        createdAt: new Date().toISOString()
      });
    }
    
    writeTransactions(transactions);
    
    return res.json({
      success: true,
      message: 'Transaction recorded successfully'
    });
    
  } catch (err) {
    console.error('Transaction recording error:', err.message);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to record transaction' 
    });
  }
});

// 3. Get User Transaction History (GET /api/payments/user/history)
app.get('/api/payments/user/history', requireAuth, (req, res) => {
  try {
    const page = Math.max(1, Number(req.query.page) || 1);
    const pageSize = Math.min(50, Math.max(1, Number(req.query.pageSize) || 10));
    const searchQuery = (req.query.search || '').toLowerCase();
    const statusFilter = req.query.status;
    
    const allTransactions = readTransactions();
    
    // Filter by user email
    let userTransactions = allTransactions.filter(tx => 
      tx.userId === req.user.email || tx.email === req.user.email
    );
    
    // Apply search filter
    if (searchQuery) {
      userTransactions = userTransactions.filter(tx => 
        (tx.description && tx.description.toLowerCase().includes(searchQuery)) ||
        (tx.reference && tx.reference.toLowerCase().includes(searchQuery)) ||
        (tx.id && tx.id.toLowerCase().includes(searchQuery))
      );
    }
    
    // Apply status filter
    if (statusFilter && statusFilter !== 'all') {
      userTransactions = userTransactions.filter(tx => 
        tx.status === statusFilter
      );
    }
    
    // Sort by timestamp (newest first)
    userTransactions.sort((a, b) => 
      new Date(b.timestamp || b.createdAt) - new Date(a.timestamp || a.createdAt)
    );
    
    // Pagination
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    const paginatedTransactions = userTransactions.slice(start, end);
    
    // Format transactions for frontend
    const formattedTransactions = paginatedTransactions.map(tx => ({
      id: tx.id,
      amount: tx.amount,
      currency: tx.currency || 'USD',
      method: tx.method || tx.provider || 'unknown',
      status: tx.status || 'pending',
      description: tx.description || `Payment via ${tx.method || tx.provider}`,
      email: tx.email,
      phone: tx.phone,
      reference: tx.reference,
      timestamp: tx.timestamp || tx.createdAt,
      receiptUrl: tx.receipt || tx.receiptUrl || null,
      note: tx.note || null
    }));
    
    return res.json({
      success: true,
      transactions: formattedTransactions,
      pagination: {
        page,
        pageSize,
        total: userTransactions.length,
        totalPages: Math.ceil(userTransactions.length / pageSize)
      }
    });
    
  } catch (err) {
    console.error('Get user history error:', err.message);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to retrieve transaction history' 
    });
  }
});

// 4. Get All Transactions - Admin Only (GET /api/payments/admin/all)
app.get('/api/payments/admin/all', adminAuth, (req, res) => {
  try {
    const page = Math.max(1, Number(req.query.page) || 1);
    const pageSize = Math.min(100, Math.max(1, Number(req.query.pageSize) || 15));
    const searchQuery = (req.query.search || '').toLowerCase();
    const statusFilter = req.query.status;
    
    let allTransactions = readTransactions();
    
    // Apply search filter
    if (searchQuery) {
      allTransactions = allTransactions.filter(tx => 
        (tx.description && tx.description.toLowerCase().includes(searchQuery)) ||
        (tx.reference && tx.reference.toLowerCase().includes(searchQuery)) ||
        (tx.email && tx.email.toLowerCase().includes(searchQuery)) ||
        (tx.id && tx.id.toLowerCase().includes(searchQuery)) ||
        (tx.userId && tx.userId.toLowerCase().includes(searchQuery))
      );
    }
    
    // Apply status filter
    if (statusFilter && statusFilter !== 'all') {
      allTransactions = allTransactions.filter(tx => 
        tx.status === statusFilter
      );
    }
    
    // Sort by timestamp (newest first)
    allTransactions.sort((a, b) => 
      new Date(b.timestamp || b.createdAt) - new Date(a.timestamp || a.createdAt)
    );
    
    // Pagination
    const start = (page - 1) * pageSize;
    const end = start + pageSize;
    const paginatedTransactions = allTransactions.slice(start, end);
    
    // Format transactions for admin view
    const formattedTransactions = paginatedTransactions.map(tx => ({
      id: tx.id,
      userId: tx.userId || tx.email,
      amount: tx.amount,
      currency: tx.currency || 'USD',
      method: tx.method || tx.provider || 'unknown',
      status: tx.status || 'pending',
      description: tx.description || `Payment via ${tx.method || tx.provider}`,
      email: tx.email,
      phone: tx.phone,
      reference: tx.reference,
      timestamp: tx.timestamp || tx.createdAt,
      receiptUrl: tx.receipt || tx.receiptUrl || null,
      note: tx.note || null,
      paidAt: tx.paidAt || null,
      updatedAt: tx.updatedAt || null
    }));
    
    return res.json({
      success: true,
      transactions: formattedTransactions,
      pagination: {
        page,
        pageSize,
        total: allTransactions.length,
        totalPages: Math.ceil(allTransactions.length / pageSize)
      }
    });
    
  } catch (err) {
    console.error('Get admin transactions error:', err.message);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to retrieve transactions' 
    });
  }
});

// 5. Export Transactions to CSV - Admin Only (GET /api/payments/export/csv)
app.get('/api/payments/export/csv', adminAuth, (req, res) => {
  try {
    const allTransactions = readTransactions();
    
    // Sort by timestamp (newest first)
    allTransactions.sort((a, b) => 
      new Date(b.timestamp || b.createdAt) - new Date(a.timestamp || a.createdAt)
    );
    
    // CSV Headers
    const headers = [
      'Transaction ID',
      'User ID/Email',
      'Amount',
      'Currency',
      'Payment Method',
      'Status',
      'Description',
      'Email',
      'Phone',
      'Reference',
      'Timestamp',
      'Receipt URL',
      'Note'
    ];
    
    // CSV Rows
    const rows = allTransactions.map(tx => [
      tx.id || '',
      tx.userId || tx.email || '',
      tx.amount || '0',
      tx.currency || 'USD',
      tx.method || tx.provider || 'unknown',
      tx.status || 'pending',
      (tx.description || '').replace(/,/g, ';'), // Escape commas
      tx.email || '',
      tx.phone || '',
      tx.reference || '',
      tx.timestamp || tx.createdAt || '',
      tx.receipt || tx.receiptUrl || '',
      (tx.note || '').replace(/,/g, ';') // Escape commas
    ]);
    
    // Build CSV content
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(','))
    ].join('\n');
    
    // Set headers for CSV download
    const filename = `smartinvest-transactions-${new Date().toISOString().split('T')[0]}.csv`;
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    
    return res.send(csvContent);
    
  } catch (err) {
    console.error('Export CSV error:', err.message);
    return res.status(500).json({ 
      success: false, 
      error: 'Failed to export transactions' 
    });
  }
});

// Admin action endpoints for transaction management
app.post('/api/payments/admin/verify', adminAuth, (req, res) => {
  try {
    const { transactionId } = req.body;
    if (!transactionId) {
      return res.status(400).json({ success: false, error: 'transactionId required' });
    }
    
    const transactions = readTransactions();
    const tx = transactions.find(t => t.id === transactionId);
    
    if (!tx) {
      return res.status(404).json({ success: false, error: 'Transaction not found' });
    }
    
    tx.status = 'completed';
    tx.verifiedAt = new Date().toISOString();
    tx.verifiedBy = req.user.email;
    tx.note = (tx.note || '') + `\nVerified by ${req.user.email} on ${new Date().toISOString()}`;
    
    writeTransactions(transactions);
    
    return res.json({ success: true, message: 'Transaction verified' });
  } catch (err) {
    console.error('Verify transaction error:', err.message);
    return res.status(500).json({ success: false, error: 'Failed to verify transaction' });
  }
});

app.post('/api/payments/admin/dispute', adminAuth, (req, res) => {
  try {
    const { transactionId, reason } = req.body;
    if (!transactionId) {
      return res.status(400).json({ success: false, error: 'transactionId required' });
    }
    
    const transactions = readTransactions();
    const tx = transactions.find(t => t.id === transactionId);
    
    if (!tx) {
      return res.status(404).json({ success: false, error: 'Transaction not found' });
    }
    
    tx.status = 'disputed';
    tx.disputedAt = new Date().toISOString();
    tx.disputedBy = req.user.email;
    tx.note = (tx.note || '') + `\nDisputed by ${req.user.email} on ${new Date().toISOString()}: ${reason || 'No reason provided'}`;
    
    writeTransactions(transactions);
    
    return res.json({ success: true, message: 'Transaction marked as disputed' });
  } catch (err) {
    console.error('Dispute transaction error:', err.message);
    return res.status(500).json({ success: false, error: 'Failed to dispute transaction' });
  }
});

app.post('/api/payments/admin/refund', adminAuth, (req, res) => {
  try {
    const { transactionId, reason } = req.body;
    if (!transactionId) {
      return res.status(400).json({ success: false, error: 'transactionId required' });
    }
    
    const transactions = readTransactions();
    const tx = transactions.find(t => t.id === transactionId);
    
    if (!tx) {
      return res.status(404).json({ success: false, error: 'Transaction not found' });
    }
    
    tx.status = 'refunded';
    tx.refundedAt = new Date().toISOString();
    tx.refundedBy = req.user.email;
    tx.note = (tx.note || '') + `\nRefunded by ${req.user.email} on ${new Date().toISOString()}: ${reason || 'No reason provided'}`;
    
    writeTransactions(transactions);
    
    return res.json({ success: true, message: 'Transaction refunded' });
  } catch (err) {
    console.error('Refund transaction error:', err.message);
    return res.status(500).json({ success: false, error: 'Failed to refund transaction' });
  }
});

app.post('/api/payments/admin/note', adminAuth, (req, res) => {
  try {
    const { transactionId, note } = req.body;
    if (!transactionId || !note) {
      return res.status(400).json({ success: false, error: 'transactionId and note required' });
    }
    
    const transactions = readTransactions();
    const tx = transactions.find(t => t.id === transactionId);
    
    if (!tx) {
      return res.status(404).json({ success: false, error: 'Transaction not found' });
    }
    
    tx.note = (tx.note || '') + `\n[${new Date().toISOString()}] ${req.user.email}: ${note}`;
    tx.updatedAt = new Date().toISOString();
    
    writeTransactions(transactions);
    
    return res.json({ success: true, message: 'Note added successfully' });
  } catch (err) {
    console.error('Add note error:', err.message);
    return res.status(500).json({ success: false, error: 'Failed to add note' });
  }
});

// ============================================================================
// END OF MODERN PAYMENT SYSTEM API
// ============================================================================

// ============================================================================
// PREMIUM BROCHURE DELIVERY & MARKETPLACE API
// ============================================================================

// Premium Brochure Delivery Endpoints
app.get('/api/user/membership-status', (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  // Check if user has premium membership
  const user = users.find(u => u.email === payload.email);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  return res.json({
    isPremium: user.premium || false,
    subscriptionStartDate: user.premiumStartDate || new Date().toISOString(),
    subscriptionEndDate: user.premiumEndDate || null,
    lastNotificationDate: user.lastBrochureNotification || null
  });
});

// Get available brochures for user
app.get('/api/brochures/available', (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const user = users.find(u => u.email === payload.email);
  if (!user || !user.premium) {
    return res.status(403).json({ error: 'Premium membership required' });
  }
  
  // Calculate weeks subscribed
  const startDate = new Date(user.premiumStartDate || Date.now());
  const now = new Date();
  const weeksSubscribed = Math.floor((now - startDate) / (1000 * 60 * 60 * 24 * 7));
  
  return res.json({
    weeksSubscribed,
    availableBrochures: brochureList.filter(b => b.deliveryWeek <= weeksSubscribed)
  });
});

// Generate PDF for brochure
app.get('/api/brochures/:brochureId/pdf', async (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const user = users.find(u => u.email === payload.email);
  if (!user || !user.premium) {
    return res.status(403).json({ error: 'Premium membership required' });
  }
  
  const { brochureId } = req.params;
  
  // In production, generate actual PDF using puppeteer or similar
  // For now, redirect to HTML version
  return res.redirect(`/public/brochures/${brochureId}.html`);
});

// Marketplace - Get all products
app.get('/api/marketplace/products', (req, res) => {
  const { category, minPrice, maxPrice, sort } = req.query;
  
  let filtered = marketplaceProducts;
  
  if (category && category !== 'all') {
    filtered = filtered.filter(p => p.category === category);
  }
  
  if (minPrice) {
    filtered = filtered.filter(p => p.price >= parseFloat(minPrice));
  }
  
  if (maxPrice) {
    filtered = filtered.filter(p => p.price <= parseFloat(maxPrice));
  }
  
  // Sort products
  if (sort === 'price-low') {
    filtered.sort((a, b) => a.price - b.price);
  } else if (sort === 'price-high') {
    filtered.sort((a, b) => b.price - a.price);
  } else if (sort === 'rating') {
    filtered.sort((a, b) => b.rating - a.rating);
  }
  
  return res.json({ products: filtered, total: filtered.length });
});

// Marketplace - Get single product
app.get('/api/marketplace/products/:id', (req, res) => {
  const product = marketplaceProducts.find(p => p.id === parseInt(req.params.id));
  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }
  return res.json(product);
});

// Marketplace - Add to cart
app.post('/api/marketplace/cart/add', (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Please login to add items to cart' });
  }
  
  const { productId, quantity } = req.body;
  const product = marketplaceProducts.find(p => p.id === productId);
  
  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }
  
  // Initialize cart if doesn't exist
  if (!userCarts[payload.email]) {
    userCarts[payload.email] = [];
  }
  
  // Check if product already in cart
  const existingItem = userCarts[payload.email].find(item => item.productId === productId);
  
  if (existingItem) {
    existingItem.quantity += quantity || 1;
  } else {
    userCarts[payload.email].push({
      productId,
      quantity: quantity || 1,
      addedAt: new Date().toISOString()
    });
  }
  
  return res.json({ 
    success: true, 
    message: 'Added to cart',
    cartCount: userCarts[payload.email].length
  });
});

// Marketplace - Get cart
app.get('/api/marketplace/cart', (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const cart = userCarts[payload.email] || [];
  const cartWithProducts = cart.map(item => {
    const product = marketplaceProducts.find(p => p.id === item.productId);
    return {
      ...item,
      product
    };
  });
  
  const total = cartWithProducts.reduce((sum, item) => sum + (item.product.price * item.quantity), 0);
  
  return res.json({ items: cartWithProducts, total, count: cart.length });
});

// Marketplace - Remove from cart
app.delete('/api/marketplace/cart/:productId', (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const productId = parseInt(req.params.productId);
  
  if (userCarts[payload.email]) {
    userCarts[payload.email] = userCarts[payload.email].filter(item => item.productId !== productId);
  }
  
  return res.json({ success: true, message: 'Item removed from cart' });
});

// Marketplace - Purchase products
app.post('/api/marketplace/purchase', async (req, res) => {
  const payload = verifyTokenFromReq(req);
  if (!payload) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  const { items, paymentMethod, mpesaPhone, paypalEmail } = req.body;
  
  if (!items || items.length === 0) {
    return res.status(400).json({ error: 'No items in order' });
  }
  
  // Calculate total
  const total = items.reduce((sum, item) => {
    const product = marketplaceProducts.find(p => p.id === item.productId);
    return sum + (product ? product.price * item.quantity : 0);
  }, 0);
  
  // Create order
  const order = {
    id: `ORD-${Date.now()}`,
    userId: payload.email,
    items,
    total,
    paymentMethod,
    status: 'pending',
    createdAt: new Date().toISOString()
  };
  
  // Process payment (integrate with existing M-Pesa/PayPal logic)
  if (paymentMethod === 'mpesa') {
    // Use existing M-Pesa integration
    order.mpesaPhone = mpesaPhone;
    order.status = 'processing';
  } else if (paymentMethod === 'paypal') {
    order.paypalEmail = paypalEmail;
    order.status = 'processing';
  }
  
  // Store order (in production, save to database)
  if (!marketplaceOrders) {
    global.marketplaceOrders = [];
  }
  marketplaceOrders.push(order);
  
  // Clear cart
  userCarts[payload.email] = [];
  
  return res.json({ 
    success: true, 
    orderId: order.id,
    message: 'Order placed successfully',
    order
  });
});

// Analytics tracking
app.post('/api/analytics/track', (req, res) => {
  const payload = verifyTokenFromReq(req);
  const { event, data, timestamp } = req.body;
  
  // Log event (in production, send to analytics service)
  console.log('Analytics Event:', {
    user: payload?.email || 'anonymous',
    event,
    data,
    timestamp
  });
  
  return res.json({ success: true });
});

// User profile (MVP personalization)
app.get('/api/profile', (req, res) => {
  const key = resolveProfileKey(req, req.body || {});
  if (!key) {
    return res.status(401).json({ success: false, error: 'Unauthorized' });
  }

  const profile = userProfiles.get(key) || null;
  return res.json({ success: true, profile });
});

app.post('/api/profile', (req, res) => {
  const key = resolveProfileKey(req, req.body || {});
  if (!key) {
    return res.status(401).json({ success: false, error: 'Unauthorized' });
  }

  const allowedGoals = ['growth', 'retirement', 'education', 'business', 'income'];
  const allowedHorizon = ['0-2', '3-5', '6-10', '10+'];
  const allowedRisk = ['low', 'medium', 'high'];

  const goal = sanitizeString(req.body?.goal || '').toLowerCase();
  const horizon = sanitizeString(req.body?.horizon || '').toLowerCase();
  const risk = sanitizeString(req.body?.risk || '').toLowerCase();
  const region = sanitizeString(req.body?.region || '').toUpperCase();
  const contribution = Number(req.body?.contribution || 0);
  const impact = Boolean(req.body?.impact);

  if (!allowedGoals.includes(goal) || !allowedHorizon.includes(horizon) || !allowedRisk.includes(risk) || !region) {
    return res.status(400).json({ success: false, error: 'Invalid profile data' });
  }

  const profile = {
    goal,
    horizon,
    risk,
    region,
    contribution: Number.isFinite(contribution) ? contribution : 0,
    impact,
    updatedAt: new Date().toISOString()
  };

  userProfiles.set(key, profile);
  return res.json({ success: true, profile });
});

// Sample marketplace products
const marketplaceProducts = [
  { id: 1, title: "Complete Investment Masterclass 2026", category: "courses", price: 2999, rating: 4.8, reviews: 1242, image: "https://via.placeholder.com/300x200?text=Investment+Course" },
  { id: 2, title: "Africa Markets Weekly Brochure", category: "brochures", price: 499, rating: 4.9, reviews: 856, premium: true, image: "https://via.placeholder.com/300x200?text=Weekly+Brochure" },
  { id: 3, title: "Portfolio Tracker Pro", category: "tools", price: 1499, rating: 4.7, reviews: 623, image: "https://via.placeholder.com/300x200?text=Portfolio+Tracker" },
  { id: 4, title: "Q1 2026 Market Analysis Report", category: "reports", price: 799, rating: 4.6, reviews: 445, image: "https://via.placeholder.com/300x200?text=Market+Report" },
  { id: 5, title: "Premium Investment Brochure Bundle", category: "brochures", price: 3999, rating: 5.0, reviews: 234, premium: true, image: "https://via.placeholder.com/300x200?text=Premium+Bundle" },
  { id: 6, title: "Crypto Investment Guide 2026", category: "courses", price: 1999, rating: 4.5, reviews: 892, image: "https://via.placeholder.com/300x200?text=Crypto+Guide" },
  { id: 7, title: "Personal Advisory Session", category: "advisory", price: 4999, rating: 5.0, reviews: 156, premium: true, image: "https://via.placeholder.com/300x200?text=Advisory+Session" },
  { id: 8, title: "Investment Proposal Templates", category: "templates", price: 599, rating: 4.4, reviews: 378, image: "https://via.placeholder.com/300x200?text=Templates" },
  { id: 9, title: "Technical Analysis Course", category: "courses", price: 2499, rating: 4.8, reviews: 1089, image: "https://via.placeholder.com/300x200?text=Technical+Analysis" },
  { id: 10, title: "Real Estate Investment Calculator", category: "tools", price: 899, rating: 4.7, reviews: 512, image: "https://via.placeholder.com/300x200?text=RE+Calculator" },
  { id: 11, title: "ESG Investing Brochure Series", category: "brochures", price: 699, rating: 4.9, reviews: 267, premium: true, image: "https://via.placeholder.com/300x200?text=ESG+Brochures" },
  { id: 12, title: "Stock Screening Tool Advanced", category: "tools", price: 1799, rating: 4.6, reviews: 445, image: "https://via.placeholder.com/300x200?text=Stock+Screener" }
];

const brochureList = [
  { id: 'weekly-insights', title: 'Africa Markets Weekly Insights', deliveryWeek: 1, description: 'Comprehensive weekly analysis of African markets' },
  { id: 'quarterly-opportunities', title: 'Investment Opportunities Q1 2026', deliveryWeek: 2, description: 'Top investment opportunities for the quarter' },
  { id: 'portfolio-optimization', title: 'Portfolio Optimization Strategies', deliveryWeek: 3, description: 'Advanced strategies to optimize your portfolio' },
  { id: 'risk-management', title: 'Risk Management Masterclass', deliveryWeek: 4, description: 'Comprehensive risk management techniques' },
  { id: 'fintech-report', title: 'African Fintech Revolution Report', deliveryWeek: 8, description: 'Deep dive into African fintech landscape' },
  { id: 'green-energy', title: 'Green Energy Investment Guide', deliveryWeek: 12, description: 'Sustainable energy investment opportunities' }
];

const userCarts = {};
const marketplaceOrders = [];

// ============================================================================
// SERVER START
// ============================================================================

app.listen(PORT, () => {
  console.log('\n🚀 SmartInvest Server Running');
  console.log(`✅ Server listening on http://localhost:${PORT}`);
  console.log(`📊 Admin panel: http://localhost:${PORT}/admin.html`);
  console.log(`🛒 Marketplace: http://localhost:${PORT}/marketplace.html`);
  console.log(`📚 Premium Brochures: Enabled`);
  console.log('💡 Check .env for M-Pesa, PayPal, etc. configuration\n');
});
